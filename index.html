<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Football Streaming - Live Football on TV for FREE - Streamed</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #1a1a1a;
            --secondary-color: #2d2d2d;
            --accent-color: #ff6b35;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --text-muted: #808080;
            --border-color: #404040;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --live-color: #dc2626;
            --scheduled-color: #059669;
            --finished-color: #6b7280;
        }

        html {
            width: 1280px;
            height: 720px;
            overflow: hidden;
        }

        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: var(--primary-color);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
            width: 1280px;
            height: 720px;
            margin: 0 auto;
            position: relative;
        }





        /* Main Content */
        .main-content {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0.5rem;
            overflow: hidden;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        /* Filters */
        .filters {
            background: var(--secondary-color);
            border-radius: 8px;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .filters-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .filters-title {
            font-size: 1rem;
            font-weight: 700;
        }

        .filter-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 0.25rem 0.5rem;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.75rem;
        }

        .filter-btn:hover,
        .filter-btn.active {
            background: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        /* Filtros Verticales */
        .vertical-filters {
            position: fixed;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            background: transparent;
            padding: 2rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .filter-group-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0;
            text-align: center;
        }

        .vertical-filter-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .vertical-filter-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .vertical-filter-btn:focus {
            background: var(--accent-color);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.5);
        }

        .vertical-filter-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 60px;
            font-size: 0.75rem;
        }

        .vertical-filter-btn:hover {
            background: rgba(255, 107, 53, 0.1);
            color: var(--accent-color);
            transform: translateX(5px);
        }

        .vertical-filter-btn.active {
            background: rgba(255, 107, 53, 0.2);
            color: var(--accent-color);
            box-shadow: none;
        }

        .filter-icon {
            font-size: 1.2rem;
            line-height: 1;
        }

        .filter-text {
            font-size: 0.6rem;
            font-weight: 500;
            text-align: center;
            line-height: 1;
        }



        /* Matches Grid */
        /* Carrusel Styles */
        .carrusel-container {
            position: relative;
            width: 100%;
            flex: 1;
            overflow: hidden;
            background: transparent;
        }

        .carrusel-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            background: transparent;
        }

        .carrusel-track {
            display: flex;
            transition: transform 0.5s ease-in-out;
            height: 100%;
            flex: 1;
            background: transparent;
        }

        .carrusel-track .match-card {
            flex: 0 0 100%;
            width: 100%;
            height: 100%;
            margin: 0;
            border-radius: 0;
        }

        .carrusel-container .carrusel-btn {
            position: absolute;
            top: 20%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .carrusel-container .carrusel-btn:hover {
            background: rgba(255, 107, 53, 0.9);
            transform: translateY(-50%) scale(1.1);
        }

        .carrusel-container .carrusel-btn:focus {
            background: rgba(255, 107, 53, 0.9);
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.6);
            outline: 3px solid var(--accent-color);
        }

        /* Estilos para el bot√≥n del carrusel que est√° fuera del contenedor */
        .carrusel-btn:not(.carrusel-container .carrusel-btn) {
            position: static;
            transform: translateX(90%);
            background: rgba(255, 107, 53, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 12px;
            cursor: pointer;
            padding: 0;
            margin: 5px 0;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .carrusel-btn:not(.carrusel-container .carrusel-btn):hover {
            background: rgba(255, 107, 53, 1);
            transform: translateX(90%) scale(1.1);
        }

        .carrusel-btn:not(.carrusel-container .carrusel-btn):focus {
            background: rgba(255, 107, 53, 1);
            transform: translateX(90%) scale(1.1);
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
            outline: 2px solid var(--accent-color);
            outline-offset: 1px;
        }

        .carrusel-container .carrusel-prev {
            left: -60px;
        }

        .carrusel-container .carrusel-next {
            right: 20px;
        }

        .indicadores-pagina {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .indicador {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .indicador.activo {
            background: #ff6b35;
            transform: scale(1.2);
        }

        .match-card {
            background: transparent;
            border-radius: 0;
            overflow: hidden;
            border: none;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .match-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .match-poster {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            opacity: 0.3;
            transition: all 0.3s ease;
        }

        .match-card:hover .match-poster {
            opacity: 0.4;
            transform: scale(1.05);
        }

        .match-card.no-poster {
            background: transparent;
        }

        .match-card.no-poster .match-overlay {
            background: transparent;
        }

        .match-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: transparent;
            display: flex;
            flex-direction: column;
        }

        .match-header {
            padding: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .match-time {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .match-status {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .status-live {
            background: #e55a2b !important;
            color: #ffffff !important;
            width: auto !important;
            height: 24px !important;
            padding: 2px 12px 0 12px !important;
            border-radius: 12px !important;
            text-decoration: none !important;
            font-size: 12px !important;
            font-weight: 600 !important;
            transition: all 0.3s ease !important;
            border: 2px solid transparent !important;
            cursor: pointer !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            outline: none !important;
            position: relative !important;
            overflow: hidden !important;
            text-shadow: none !important;
        }



        .status-live:hover {
            transform: scale(1.05);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .status-scheduled {
            background: var(--scheduled-color);
            color: white;
        }

        .status-finished {
            background: var(--finished-color);
            color: white;
        }

        .contenido-texto {
            position: absolute;
            top: 0%;
            left: 8%;
            transform: scale(0.98);
            transform-origin: left top;
            max-width: 70%;
            z-index: 10 !important;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            /* Prevenir que el foco de elementos hijos afecte la posici√≥n */
            pointer-events: auto;
        }



        .branding {
            font-size: 0.8rem;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .contenido-texto h2 {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            line-height: 1.2;
        }

        .metadata {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            font-size: 1rem;
            color: #b3b3b3;
        }

        .bullet {
            color: #ff6b35;
            font-weight: bold;
        }

        .contenido-texto p {
            font-size: 1.1rem;
            line-height: 1.5;
            margin-bottom: 1.5rem;
            color: #e0e0e0;
            max-width: 70%;
            text-align: left;
        }

        .botones-container {
            display: flex;
            gap: 10px;
            max-width: 100%;
            width: 100%;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: flex-start;
        }

        .botones-container a,
        .botones-container button {
            width: 236px;
            height: 42px;
            padding: 0;
            border: none;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.7rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--accent-color);
            color: white;
            text-decoration: none;
        }

        .botones-container a:hover,
        .botones-container button:hover {
            background: rgba(255, 107, 53, 1);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }



        @keyframes pulse-live {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(220, 38, 38, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(220, 38, 38, 0.6);
            }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .status-scheduled {
            background: linear-gradient(135deg, #059669, #10b981);
            color: white;
            font-weight: 700;
            width: auto !important;
            height: 24px !important;
            padding: 2px 12px 0 12px !important;
            border-radius: 12px !important;
            font-size: 12px !important;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(5, 150, 105, 0.4);
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            text-shadow: none !important;
        }

        .status-finished {
            background: linear-gradient(135deg, #6b7280, #9ca3af);
            color: white;
            font-weight: 700;
            width: auto !important;
            height: 24px !important;
            padding: 2px 12px 0 12px !important;
            border-radius: 12px !important;
            font-size: 12px !important;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(107, 114, 128, 0.4);
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            text-shadow: none !important;
        }

        /* Estilos eliminados - ahora usando .contenido-texto */

        .action-btn {
            cursor: pointer;
        }

        .btn-watch {
            background: #000000 !important;
            color: #ffffff !important;
            width: 220px !important;
            height: 50px !important;
            padding: 0 !important;
            border-radius: 28px !important;
            text-decoration: none !important;
            font-size: 18px !important;
            font-weight: 600 !important;
            transition: all 0.3s ease !important;
            border: 4px solid #ff6b35 !important;
            cursor: pointer !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            outline: none !important;
            position: relative !important;
            overflow: hidden !important;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.3) !important;
            -webkit-appearance: none !important;
            -webkit-tap-highlight-color: transparent !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            margin: 2px !important;
            min-width: 220px !important;
            min-height: 50px !important;
            max-width: none !important;
            max-height: none !important;
        }

        /* Eliminar pseudo-elemento para que solo quede el borde s√≥lido */
        .btn-watch::before {
            display: none !important;
        }

        .btn-watch:hover {
            transform: scale(1.05);
        }

        .btn-watch:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: 3px;
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.5);
        }

        /* Optimizaciones espec√≠ficas para Android */
        @media screen and (max-width: 1920px) {
            .btn-watch {
                font-size: 16px !important;
                width: 180px !important;
                height: 52px !important;
            }
        }

        /* Para Android TV espec√≠ficamente */
        @media screen and (max-width: 1280px) {
            .btn-watch {
                font-size: 14px !important;
                width: 160px !important;
                height: 48px !important;
                border-width: 3px !important;
            }
        }

        /* Asegurar que el texto sea visible en todos los dispositivos */
        .btn-watch span,
        .btn-watch {
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8) !important;
            font-family: 'Arial', sans-serif !important;
            letter-spacing: 0.5px !important;
            font-size: 18px !important;
        }

        /* Optimizaci√≥n espec√≠fica para Android TV */
        .btn-watch {
            -webkit-transform: translateZ(0) !important;
            transform: translateZ(0) !important;
            backface-visibility: hidden !important;
            -webkit-backface-visibility: hidden !important;
        }



        /* Asegurar que el texto est√© siempre visible */
        .btn-watch span {
            position: relative !important;
            z-index: 10 !important;
            color: #ffffff !important;
            font-weight: bold !important;
            font-size: 18px !important;
        }



        /* Evitar que el foco del bot√≥n afecte el layout del carrusel */
        .btn-watch:focus ~ .carrusel-track,
        .btn-watch:focus + .carrusel-track {
            transform: none !important;
        }

        .btn-details {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .btn-details:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--accent-color);
            color: var(--accent-color);
            transform: translateY(-2px);
        }



        /* Trending Now Row */
        .row {
            position: absolute;
            bottom: 17.82%;
            left: 7%;
            z-index: 50;
            margin: 0;
        }

        #row-trending-top {
            position: absolute !important;
            bottom: 16.256% !important;
            left: 7% !important;
            z-index: 50 !important;
            margin: 0 !important;
            width: 90% !important;
            overflow: hidden !important;
        }

        .row-track {
            display: flex;
            gap: 1rem;
            overflow-x: scroll !important;
            overflow-y: hidden !important;
            padding: 0.5rem 0;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
            white-space: nowrap !important;
            width: 100% !important;
            min-width: max-content !important;
            scroll-behavior: smooth !important;
        }

        .row h3 {
            color: var(--text-primary);
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            padding-top: 5%;
            text-transform: uppercase;
            letter-spacing: 1px;
        }



        .row-track::-webkit-scrollbar {
            display: none;
        }

        .row-track::-webkit-scrollbar-track {
            display: none;
        }

        .row-track::-webkit-scrollbar-thumb {
            display: none;
        }

        .row-track::-webkit-scrollbar-thumb:hover {
            display: none;
        }
        
        /* Transiciones suaves para actualizaciones */
        .viewer-count {
            transition: all 0.3s ease-in-out;
        }
        
        .tile {
            transition: opacity 0.3s ease-in-out;
        }
        
        .tile img {
            transition: opacity 0.3s ease-in-out;
        }
        
        /* Asegurar que no haya l√≠neas o bordes visibles */
        .tile * {
            border: none !important;
            outline: none !important;
        }
        
        .tile::before,
        .tile::after {
            display: none !important;
        }

        .tile {
            background: var(--secondary-color);
            border: none;
            border-radius: 8px;
            padding: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 216px;
            height: 126px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: none;
        }

        .tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .tile-overlay {
            display: none;
        }

        .tile-subtitle {
            display: block;
            font-size: 0.8rem;
            color: #ccc;
            margin-bottom: 0.25rem;
        }

        .tile-title {
            display: block;
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .platform-logo {
            display: block;
            font-size: 0.7rem;
            color: #999;
            text-transform: uppercase;
            font-weight: 500;
        }

        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .tile:focus {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(255, 107, 53, 0.7);
            outline: 3px solid var(--accent-color);
            outline-offset: 2px;
        }

        /* Streams Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        /* Universal Stream Overlay */
        .stream-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            backdrop-filter: blur(10px);
        }

        .stream-overlay-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .stream-overlay-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .stream-overlay-title {
            color: var(--text-primary);
            font-size: 1.2rem;
            font-weight: 600;
            margin: 0;
        }

        .stream-overlay-close {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .stream-overlay-close:hover {
            background: rgba(255, 107, 53, 0.2);
            color: var(--accent-color);
        }

        .stream-overlay-body {
            flex: 1;
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stream-overlay-body iframe {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background: #000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--secondary-color);
            border-radius: 12px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid var(--border-color);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 700;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: var(--primary-color);
            color: var(--text-primary);
        }

        .streams-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .stream-item {
            background: var(--primary-color);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stream-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .stream-quality {
            background: var(--success-color);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .stream-source {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .stream-actions {
            display: flex;
            gap: 0.5rem;
        }

        .stream-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.875rem;
        }

        .btn-embed {
            background: var(--accent-color);
            color: white;
        }

        .btn-embed:hover {
            background: #e55a2b;
        }

        .btn-copy {
            background: var(--success-color);
            color: white;
        }

        .btn-copy:hover {
            background: #059669;
        }

        /* Loading */
        .loading {
            display: none;
            text-align: center;
            padding: 3rem;
        }

        .spinner {
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error/Empty States */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }

        .empty-icon {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            opacity: 0.6;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }

        .empty-state h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .empty-state p {
            font-size: 1rem;
            color: var(--text-secondary);
            margin: 0;
        }

        /* Footer */
        .footer {
            background: var(--secondary-color);
            border-top: 1px solid var(--border-color);
            padding: 2rem;
            margin-top: 4rem;
            text-align: center;
        }

        .footer-content {
            max-width: 1300px;
            margin: 0 auto;
        }

        .footer p {
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            flex-wrap: wrap;
        }

        .footer-link {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .footer-link:hover {
            color: var(--accent-color);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header-content {
                padding: 1rem;
                flex-direction: column;
                gap: 1rem;
            }

            .nav-menu {
                gap: 1rem;
            }

            .hero h1 {
                font-size: 2.5rem;
            }

            .hero-buttons {
                flex-direction: column;
                align-items: center;
            }

            .main-content {
                padding: 1rem;
            }

            .filters-header {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }

            .filter-buttons {
                justify-content: center;
            }

            .matches-grid {
                grid-template-columns: 1fr;
            }

            .teams {
                flex-direction: column;
                gap: 1rem;
            }

            .team.away {
                justify-content: center;
            }

            .vs {
                margin: 0;
            }

            .match-actions {
                flex-direction: column;
            }
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 1001;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: var(--success-color);
        }

        .notification.error {
            background: var(--error-color);
        }
    </style>
</head>
<body>



    <!-- Main Content -->
    <main class="main-content">
        <!-- Loading -->
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Cargando partidos...</p>
        </div>

        <!-- Bot√≥n del carrusel movido aqu√≠ arriba -->
        <button class="carrusel-btn carrusel-next" id="carruselNext" onclick="moverCarrusel(1)" tabindex="13">
            ‚ùØ
        </button>

        <!-- Filtros Verticales -->
        <div class="vertical-filters">
            <div class="filter-group">
                <h3 class="filter-group-title">Estado</h3>
                <div class="vertical-filter-buttons">
                    <button class="vertical-filter-btn" onclick="filterByStatus('live')" title="En Vivo" tabindex="1">
                        <span class="filter-text">En Vivo</span>
                    </button>
                    <button class="vertical-filter-btn" onclick="filterByStatus('scheduled')" title="Programados" tabindex="2">
                        <span class="filter-text">Programados</span>
                    </button>
                    <button class="vertical-filter-btn" onclick="filterByStatus('finished')" title="Finalizados" tabindex="3">
                        <span class="filter-text">Finalizados</span>
                    </button>
                </div>
            </div>
            
            <div class="filter-group">
                <h3 class="filter-group-title">Deportes</h3>
                <div class="vertical-filter-buttons">
                    <button class="vertical-filter-btn" onclick="loadSport('football')" title="F√∫tbol" tabindex="4">
                        <span class="filter-text">F√∫tbol</span>
                    </button>
                    <button class="vertical-filter-btn" onclick="loadSport('basketball')" title="Baloncesto" tabindex="5">
                        <span class="filter-text">Baloncesto</span>
                    </button>
                    <button class="vertical-filter-btn" onclick="loadSport('cricket')" title="Cricket" tabindex="6">
                        <span class="filter-text">Cricket</span>
                    </button>
                </div>
            </div>
            
            <div class="filter-group">
                <h3 class="filter-group-title">Ligas</h3>
                <div class="vertical-filter-buttons">
                    <button class="vertical-filter-btn" onclick="filterByLeague('MLS')" title="MLS" tabindex="7">
                        <span class="filter-text">MLS</span>
                    </button>
                    <button class="vertical-filter-btn" onclick="filterByLeague('Premier League')" title="Premier League" tabindex="8">
                        <span class="filter-text">Premier</span>
                    </button>
                                        <button class="vertical-filter-btn" onclick="filterByLeague('La Liga')" title="La Liga" tabindex="9">
                        <span class="filter-text">La Liga</span>
                    </button>
            <button class="vertical-filter-btn" onclick="filterByChampionsLeague()" title="Champions League" tabindex="10">
                <span class="filter-text">Champions</span>
            </button>
                </div>
            </div>
        </div>

        <!-- Carrusel de Partidos -->
        <div class="carrusel-container">
            <div class="carrusel-wrapper" id="carruselWrapper">
                <div class="carrusel-track" id="carruselTrack">
                    <!-- Las tarjetas se cargar√°n aqu√≠ -->
                </div>
            </div>
            
            <!-- Botones de navegaci√≥n -->
            <button class="carrusel-btn carrusel-prev" id="carruselPrev" onclick="moverCarrusel(-1)" style="display: none;" tabindex="12">
                ‚ùÆ
            </button>
            
            <!-- Indicadores de p√°gina -->
            <div class="indicadores-pagina" id="indicadoresPagina">
                <!-- Los indicadores se generar√°n din√°micamente -->
            </div>
        </div>

        <!-- Trending Now -->
        <div class="row" id="row-trending-top">
                    <h3>TENDENCIAS</h3>
            <div class="row-track" role="list">
                <!-- Las tarjetas se cargar√°n din√°micamente aqu√≠ -->
            </div>
        </div>
    </main>

    <!-- Streams Modal -->
    <div class="modal" id="streamsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">Streams Disponibles</h3>
                <button class="close-btn" onclick="closeModal()">&times;</button>
            </div>
            <div class="streams-list" id="streamsList">
                <!-- Streams will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Universal Stream Overlay -->
    <div class="stream-overlay" id="streamOverlay">
        <div class="stream-overlay-content">
            <div class="stream-overlay-header">
                <h3 class="stream-overlay-title" id="streamOverlayTitle">Stream</h3>
                <button class="stream-overlay-close" onclick="closeStreamOverlay()">&times;</button>
            </div>
            <div class="stream-overlay-body">
                <iframe id="streamIframe" src="" frameborder="0" allowfullscreen></iframe>
            </div>
        </div>
    </div>



    <script>
        let allMatches = [];
        let currentMatches = [];
        let currentFilter = 'all';
        let currentSport = 'football';
        let mlsTeams = []; // Array para almacenar equipos de MLS

        // Funci√≥n para obtener equipos de MLS desde ESPN API
        async function loadMLSTeams() {
            try {
                console.log('üîç Cargando equipos de MLS desde ESPN API...');
                
                // URL de la API de ESPN para MLS
                const response = await fetch('https://site.api.espn.com/apis/site/v2/sports/soccer/usa.1/teams');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.sports && data.sports[0] && data.sports[0].leagues && data.sports[0].leagues[0] && data.sports[0].leagues[0].teams) {
                    mlsTeams = data.sports[0].leagues[0].teams.map(team => ({
                        name: team.team.name,
                        abbreviation: team.team.abbreviation,
                        displayName: team.team.displayName,
                        shortName: team.team.shortName
                    }));
                    
                    console.log('‚úÖ Equipos de MLS cargados:', mlsTeams.length);
                    console.log('üìã Lista de equipos MLS:', mlsTeams.map(t => t.name));
                    
                    return mlsTeams;
                } else {
                    throw new Error('Estructura de datos inesperada en ESPN API');
                }
                
            } catch (error) {
                console.error('‚ùå Error cargando equipos MLS:', error);
                
                // Fallback con equipos MLS conocidos
                mlsTeams = [
                    { name: 'Atlanta United FC', abbreviation: 'ATL' },
                    { name: 'Austin FC', abbreviation: 'AUS' },
                    { name: 'Charlotte FC', abbreviation: 'CLT' },
                    { name: 'Chicago Fire FC', abbreviation: 'CHI' },
                    { name: 'Colorado Rapids', abbreviation: 'COL' },
                    { name: 'Columbus Crew', abbreviation: 'CLB' },
                    { name: 'D.C. United', abbreviation: 'DC' },
                    { name: 'FC Cincinnati', abbreviation: 'CIN' },
                    { name: 'FC Dallas', abbreviation: 'DAL' },
                    { name: 'Houston Dynamo FC', abbreviation: 'HOU' },
                    { name: 'Inter Miami CF', abbreviation: 'MIA' },
                    { name: 'LA Galaxy', abbreviation: 'LA' },
                    { name: 'Los Angeles FC', abbreviation: 'LAFC' },
                    { name: 'Minnesota United FC', abbreviation: 'MIN' },
                    { name: 'Montreal Impact', abbreviation: 'MTL' },
                    { name: 'Nashville SC', abbreviation: 'NSH' },
                    { name: 'New England Revolution', abbreviation: 'NE' },
                    { name: 'New York City FC', abbreviation: 'NYC' },
                    { name: 'New York Red Bulls', abbreviation: 'NY' },
                    { name: 'Orlando City SC', abbreviation: 'ORL' },
                    { name: 'Philadelphia Union', abbreviation: 'PHI' },
                    { name: 'Portland Timbers', abbreviation: 'POR' },
                    { name: 'Real Salt Lake', abbreviation: 'RSL' },
                    { name: 'San Jose Earthquakes', abbreviation: 'SJ' },
                    { name: 'Seattle Sounders FC', abbreviation: 'SEA' },
                    { name: 'Sporting Kansas City', abbreviation: 'SKC' },
                    { name: 'Toronto FC', abbreviation: 'TOR' },
                    { name: 'Vancouver Whitecaps FC', abbreviation: 'VAN' },
                    { name: 'St. Louis City SC', abbreviation: 'STL' }
                ];
                
                console.log('üîÑ Usando lista fallback de equipos MLS:', mlsTeams.length);
                return mlsTeams;
            }
        }

        // Funci√≥n para verificar si un partido es de MLS
        function isMLSMatch(match) {
            if (!mlsTeams || mlsTeams.length === 0) {
                console.log('‚ùå No hay equipos MLS cargados');
                return false;
            }
            
            let homeTeam = '';
            let awayTeam = '';
            
            // Extraer nombres de equipos
            if (match.teams) {
                try {
                    const teams = typeof match.teams === 'string' ? JSON.parse(match.teams) : match.teams;
                    if (teams.home && teams.home.name) {
                        homeTeam = teams.home.name.toLowerCase();
                    }
                    if (teams.away && teams.away.name) {
                        awayTeam = teams.away.name.toLowerCase();
                    }
                } catch (e) {
                    console.error('Error parseando teams:', e.message);
                }
            }
            
            // Si no hay equipos, intentar extraer del t√≠tulo
            if (!homeTeam && !awayTeam && match.title) {
                const title = match.title.toLowerCase();
                if (title.includes(' vs ')) {
                    const parts = title.split(' vs ');
                    homeTeam = parts[0].trim();
                    awayTeam = parts[1].trim();
                }
            }
            
            // Verificar si alguno de los equipos es de MLS
            const isMLS = mlsTeams.some(mlsTeam => {
                const mlsName = mlsTeam.name.toLowerCase();
                const matchFound = homeTeam.includes(mlsName) || awayTeam.includes(mlsName) ||
                       mlsName.includes(homeTeam) || mlsName.includes(awayTeam);
                
                if (matchFound) {
                    console.log(`‚úÖ Partido MLS encontrado: ${homeTeam} vs ${awayTeam} (coincide con: ${mlsName})`);
                }
                
                return matchFound;
            });
            
            if (!isMLS && (homeTeam || awayTeam)) {
                console.log(`‚ùå No es MLS: ${homeTeam} vs ${awayTeam}`);
            }
            
            return isMLS;
        }

        // Utility Functions
        function showLoading(show) {
            // Deshabilitado para evitar movimiento del contenedor
            // document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function showNotification(message, type = 'success') {
            // Notificaciones desactivadas por solicitud
            return;
        }

        function formatDate(dateString) {
            if (!dateString) return 'Fecha no disponible';
            
            try {
                let date;
                if (typeof dateString === 'number') {
                    date = new Date(dateString);
                } else {
                    date = new Date(dateString);
                }
                
                if (isNaN(date.getTime())) return 'Fecha inv√°lida';
                
                return date.toLocaleString('es-ES', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                return 'Error de fecha';
            }
        }

        function getMatchStatus(match) {
            if (match.status) return match.status;
            
            // Usar time o date, cualquiera que est√© disponible
            const matchTime = match.time || match.date;
            
            if (matchTime) {
                const now = new Date();
                let parsedTime;
                
                if (typeof matchTime === 'number') {
                    parsedTime = new Date(matchTime);
                } else {
                    parsedTime = new Date(matchTime);
                }
                
                if (isNaN(parsedTime.getTime())) return 'unknown';
                
                const timeDiff = parsedTime - now;
                const hoursDiff = timeDiff / (1000 * 60 * 60);
                
                // Si es futuro (m√°s de 1 hora adelante)
                if (hoursDiff > 1) return 'scheduled';
                
                // Si est√° en vivo (entre -3 horas y +1 hora)
                if (hoursDiff >= -3 && hoursDiff <= 1) return 'live';
                
                // Si es pasado (m√°s de 3 horas atr√°s)
                return 'finished';
            }
            
            return 'unknown';
        }



        function loadTeamBadge(badgeId, elementId) {
            try {
                const logoElement = document.getElementById(elementId);
                if (logoElement) {
                    const imageUrl = `https://streamed.pk/api/images/proxy/${badgeId}.webp`;
                    logoElement.innerHTML = `<img src="${imageUrl}" alt="Team Logo" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">`;
                }
            } catch (error) {
                console.error(`Error cargando badge ${badgeId}:`, error.message);
            }
        }

        function limpiarNombreEquipo(nombre) {
            if (!nombre) return 'Equipo';
            
            let nombreLimpio = nombre.trim();
            
            // Remover informaci√≥n extra com√∫n
            const patronesARemover = [
                /\([^)]*\)/g,  // Par√©ntesis y su contenido
                /\[[^\]]*\]/g,  // Corchetes y su contenido
                /\d{1,2}:\d{2}/g,  // Horarios (HH:MM)
                /\d{1,2}:\d{2}\s*(AM|PM)/gi,  // Horarios con AM/PM
                /vs\.?/gi,  // "vs" o "vs."
                /v\.?/gi,   // "v" o "v."
                /-\s*$/g,   // Gui√≥n al final
                /^\s*-\s*/g, // Gui√≥n al inicio
                /\s+/g      // M√∫ltiples espacios
            ];
            
            patronesARemover.forEach(patron => {
                nombreLimpio = nombreLimpio.replace(patron, ' ');
            });
            
            // Limpiar espacios extra
            nombreLimpio = nombreLimpio.trim();
            
            // Si qued√≥ vac√≠o, usar nombre original
            if (!nombreLimpio) {
                nombreLimpio = nombre.trim();
            }
            
            // Limitar longitud
            if (nombreLimpio.length > 30) {
                nombreLimpio = nombreLimpio.substring(0, 30) + '...';
            }
            
            return nombreLimpio;
        }

        function extractTeamsFromTitle(title) {
            if (!title || typeof title !== 'string') return null;
            const normalized = title
                .replace(/\s+vs\.?\s+/i, ' vs ')
                .replace(/\s+v\.?\s+/i, ' vs ')
                .replace(/\s+-\s+/g, ' vs ')
                .replace(/\s+‚Äî\s+/g, ' vs ')
                .replace(/\s+at\s+/i, ' vs ');
            const parts = normalized.split(' vs ');
            if (parts.length === 2) {
                return [parts[0].trim(), parts[1].trim()];
            }
            return null;
        }

        // Normalizar nombres de equipos al espa√±ol (solo equipos; competencias se mantienen normales)
        function normalizeTeamSpanish(name) {
            if (!name || typeof name !== 'string') return name;
            let n = name.trim();
            const lower = n.toLowerCase();
            // Mapeos puntuales comunes
            if (/(red\s*star\s*belgrade|crvena\s*zvezda)/i.test(lower)) return 'Estrella Roja';
            if (/bodo\/?glimt|bod√∏\/?glimt/i.test(lower)) return 'Bod√∏/Glimt';
            if (/kairat\s*almaty/i.test(lower)) return 'Kairat';
            // Dejar el resto igual
            return n;
        }

        function createMatchCard(match) {
            const status = getMatchStatus(match);
            const statusText = {
                'live': 'EN VIVO',
                'scheduled': 'PROGRAMADO',
                'finished': 'FINALIZADO',
                'unknown': 'DESCONOCIDO'
            };

            // Extract team information
            let homeTeam = 'Equipo Local';
            let awayTeam = 'Equipo Visitante';
            let homeBadge = null;
            let awayBadge = null;

            // Primero intentar extraer del campo teams
            if (match.teams) {
                try {
                    const teams = typeof match.teams === 'string' ? JSON.parse(match.teams) : match.teams;
                    if (teams.home && teams.home.name) {
                        homeTeam = teams.home.name;
                        homeBadge = teams.home.badge;
                    }
                    if (teams.away && teams.away.name) {
                        awayTeam = teams.away.name;
                        awayBadge = teams.away.badge;
                    }
                } catch (e) {
                    console.error('Error parseando teams:', e.message);
                }
            }

            // Si no se encontraron equipos, intentar extraer del t√≠tulo (robusto)
            if (homeTeam === 'Equipo Local' && awayTeam === 'Equipo Visitante' && match.title) {
                const parsed = extractTeamsFromTitle(match.title);
                if (parsed) {
                    homeTeam = parsed[0];
                    awayTeam = parsed[1];
                    console.log('‚úÖ Equipos extra√≠dos (robusto):', homeTeam, 'vs', awayTeam);
                } else {
                    const title = match.title;
                    if (title.includes(' vs ')) {
                        const parts = title.split(' vs ');
                        if (parts.length === 2) {
                            homeTeam = parts[0].trim();
                            awayTeam = parts[1].trim();
                        }
                    } else if (title.includes(' - ') && !title.includes(' vs ')) {
                        const parts = title.split(' - ');
                        if (parts.length === 2) {
                            homeTeam = parts[0].trim();
                            awayTeam = parts[1].trim();
                        }
                    } else if (title.includes(' v ')) {
                        const parts = title.split(' v ');
                        if (parts.length === 2) {
                            homeTeam = parts[0].trim();
                            awayTeam = parts[1].trim();
                        }
                    } else {
                        homeTeam = title;
                        awayTeam = 'vs';
                    }
                }

                // Limpiar nombres de equipos
                homeTeam = limpiarNombreEquipo(homeTeam);
                awayTeam = limpiarNombreEquipo(awayTeam);
            }

            // Normalizar equipos a espa√±ol (solo equipos)
            homeTeam = normalizeTeamSpanish(homeTeam);
            awayTeam = normalizeTeamSpanish(awayTeam);

            const league = match.league || match.competition || match.tournament || match.event || match.category || 'Liga';
            const sources = match.sources || match.streams || [];
            
            // Obtener URL de la imagen del partido usando la API de Streamed correctamente
            let posterUrl = null;
            
            // 1. Intentar usar el poster del partido si existe
            if (match.poster) {
                // Si el poster ya es una URL completa (como https://ppv.to/...)
                if (match.poster.startsWith('http')) {
                    posterUrl = match.poster;
                    console.log('üñºÔ∏è Usando poster externo:', posterUrl);
                }
                // Si el poster es una ruta relativa de Streamed
                else {
                    // Si ya incluye /api/images/poster/ o /api/images/proxy/
                    if (match.poster.startsWith('/api/images/poster/')) {
                        posterUrl = `https://streamed.pk${match.poster}`;
                    } else if (match.poster.startsWith('api/images/poster/')) {
                        posterUrl = `https://streamed.pk/${match.poster}`;
                    } else if (match.poster.startsWith('/api/images/proxy/')) {
                        posterUrl = `https://streamed.pk${match.poster}`;
                    } else if (match.poster.startsWith('api/images/proxy/')) {
                        posterUrl = `https://streamed.pk/${match.poster}`;
                    } else {
                        // Si es solo el ID, agregar la ruta completa usando proxy (seguro)
                        posterUrl = `https://streamed.pk/api/images/proxy/${match.poster}`;
                    }
                    console.log('üñºÔ∏è Usando poster de Streamed:', posterUrl);
                }
            }
            // 2. Intentar construir poster compuesto como en el principal: /api/images/poster/{home}/{away}.webp
            else if (match?.teams?.home?.badge && match?.teams?.away?.badge) {
                const home = match.teams.home.badge;
                const away = match.teams.away.badge;
                posterUrl = `https://streamed.pk/api/images/poster/${home}/${away}.webp`;
                console.log('üñºÔ∏è Usando poster compuesto:', posterUrl);
            }
            // 3. Si no hay poster, intentar usar el badge del equipo local
            else if (match?.teams?.home?.badge) {
                posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.home.badge}.webp`;
                console.log('üñºÔ∏è Usando badge equipo local:', posterUrl);
            }
            // 4. Si no hay badge del equipo local, intentar con el equipo visitante
            else if (match?.teams?.away?.badge) {
                posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.away.badge}.webp`;
                console.log('üñºÔ∏è Usando badge equipo visitante:', posterUrl);
            }
            // 5. Si no hay estructura teams, intentar generar un badge basado en el t√≠tulo
            else if (match.title) {
                // Generar un hash simple del t√≠tulo para crear un badge √∫nico
                const titleHash = btoa(match.title).replace(/[^a-zA-Z0-9]/g, '').substring(0, 20);
                posterUrl = `https://streamed.pk/api/images/proxy/${titleHash}.webp`;
                console.log('üñºÔ∏è Usando badge generado del t√≠tulo:', posterUrl);
            }
            else {
                console.log('‚ùå No se encontr√≥ imagen para:', match.title, 'Teams:', match.teams);
            }

            const card = document.createElement('div');
            card.className = 'match-card';
            card.setAttribute('data-match-id', match.id || 'unknown');
            card.setAttribute('data-status', status);

            // Precompute stable logo IDs
            const safeId = (match.id || String(Math.random()).slice(2)).toString().replace(/[^a-zA-Z0-9_-]/g, '');
            const homeLogoId = `home-logo-${safeId}`;
            const awayLogoId = `away-logo-${safeId}`;
            
            // Poster images removed - user will add their own
            card.classList.add('no-poster');
            
            card.innerHTML += `
                <div class="match-overlay">
                    <div class="contenido-texto">
                        <div class="branding">Koogle TV</div>
                        <h2>${homeTeam} vs ${awayTeam}</h2>
                        <div class="metadata">
                            <span>${formatDate(match.date || match.time)}</span>
                            <span class="bullet">‚Ä¢</span>
                            <span>${league}</span>
                            <span class="bullet">‚Ä¢</span>
                            <span class="status-${status}">${statusText[status]}</span>
                        </div>
                        <p>Disfruta de la pasi√≥n del f√∫tbol en su m√°xima expresi√≥n. Partidos llenos de emoci√≥n, goles espectaculares y momentos inolvidables que te mantendr√°n al borde del asiento.</p>
                        <div class="botones-container">
                            <button class="action-btn btn-watch" onclick="showStreams('${match.id}', '${homeTeam} vs ${awayTeam}')" tabindex="11">
                                <span style="position: relative; z-index: 2;">VER AHORA</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Load team badges with stable IDs
            if (homeBadge) {
                loadTeamBadge(homeBadge, homeLogoId);
            }
            if (awayBadge) {
                loadTeamBadge(awayBadge, awayLogoId);
            }
            
            return card;
        }

        let currentSlide = 0;
        let totalSlides = 0;

        function displayMatches(matches) {
            const track = document.getElementById('carruselTrack');
            track.innerHTML = '';
            
            if (matches.length === 0) {
                track.innerHTML = `
                    <div class="empty-state" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: white;">
                        <div class="empty-icon" style="font-size: 4rem; margin-bottom: 1rem;">‚öΩ</div>
                        <h3>No se encontraron partidos</h3>
                        <p>Intenta con otros filtros o deportes</p>
                    </div>
                `;
                return;
            }
            
            // Usar todos los partidos disponibles en el carrusel
            const matchesToShow = matches;
            totalSlides = matchesToShow.length;
            currentSlide = 0;
            
            matchesToShow.forEach(match => {
                const card = createMatchCard(match);
                track.appendChild(card);
            });
            
            // Actualizar indicadores
            actualizarIndicadores();
            // Mostrar primera tarjeta
            mostrarSlide(0);
        }

        function normalizeToDate(value) {
            try {
                if (!value) return null;
                if (typeof value === 'number') {
                    // Aceptar epoch en segundos o milisegundos
                    const ms = value < 1e12 ? value * 1000 : value;
                    const d = new Date(ms);
                    return isNaN(d.getTime()) ? null : d;
                }
                if (typeof value === 'string') {
                    const d = new Date(value);
                    // Si falla parseo directo, intentar como n√∫mero
                    if (isNaN(d.getTime())) {
                        const num = Number(value);
                        if (!isNaN(num)) {
                            const ms = num < 1e12 ? num * 1000 : num;
                            const d2 = new Date(ms);
                            return isNaN(d2.getTime()) ? null : d2;
                        }
                    }
                    return isNaN(d.getTime()) ? null : d;
                }
                if (value instanceof Date) {
                    return isNaN(value.getTime()) ? null : value;
                }
                return null;
            } catch (_) { return null; }
        }

        function isSameLocalDay(a, b) {
            return a.getFullYear() === b.getFullYear() &&
                   a.getMonth() === b.getMonth() &&
                   a.getDate() === b.getDate();
        }

        function filterMatchesForDate(matches, targetDate) {
            return matches.filter(match => {
                const raw = match.date ?? match.time ?? match.startTime ?? null;
                const d = normalizeToDate(raw);
                return d ? isSameLocalDay(d, targetDate) : false;
            });
        }

        function filterMatchesForHour(matches, targetHour) {
            return matches.filter(match => {
                const raw = match.date ?? match.time ?? match.startTime ?? null;
                const d = normalizeToDate(raw);
                return d ? d.getHours() === targetHour : false;
            });
        }

        async function loadMatches(sport = 'football') {
            try {
                // Primero cargar equipos de MLS
                await loadMLSTeams();
                
                console.log('üîç Cargando partidos desde Streamed API...');
                const response = await fetch(`https://streamed.pk/api/matches/${sport}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const matches = await response.json();
                
                if (!Array.isArray(matches)) {
                    throw new Error('La respuesta no es un array de partidos');
                }
                
                console.log(`üìä Total de partidos recibidos: ${matches.length}`);
                
                // Diagn√≥stico de categor√≠as
                logCategoryDiagnostics(matches);
                
                // Usar todos los partidos
                allMatches = matches;
                
                // Enriquecer competiciones consultando diario externo (ftvhd) y asignar overrides por coincidencia
                const diary = await fetchDiaryToday();
                diaryAssignCompetitionsForToday(allMatches, diary);
                
                const now = new Date();
                
                // Filtrar solo los de HOY (hora local)
                const todayMatches = filterMatchesForDate(allMatches, now);
                console.log(`üìÖ Partidos de HOY: ${todayMatches.length}`);
                
                // Guardar todos los partidos de HOY pero NO mostrarlos autom√°ticamente
                currentMatches = todayMatches;
                
                currentSport = sport;
                
                displayMatches(currentMatches);
                
                // Actualizar secci√≥n de tendencias con partidos populares de HOY
                await updateTrendingSection();
                
            } catch (error) {
                console.error('Error loading matches:', error);
                displayMatches([]);
            }
        }

        function loadAllMatches() {
            loadMatches(currentSport);
        }

        // Funciones del carrusel
        function moverCarrusel(direccion) {
            // Verificar si el bot√≥n del carrusel est√° enfocado
            const focusedElement = document.activeElement;
            const isCarouselButtonFocused = focusedElement && 
                (focusedElement.id === 'carruselNext' || focusedElement.id === 'carruselPrev');
            
            // Solo mover si el bot√≥n est√° enfocado
            if (!isCarouselButtonFocused) {
                console.log('üö´ Carrusel no movido: bot√≥n no enfocado');
                return;
            }
            
            const nuevaPosicion = currentSlide + direccion;
            
            if (nuevaPosicion >= 0 && nuevaPosicion < totalSlides) {
                mostrarSlide(nuevaPosicion);
                console.log('‚úÖ Carrusel movido:', direccion > 0 ? 'siguiente' : 'anterior');
            }
        }

        function mostrarSlide(indice) {
            if (indice < 0 || indice >= totalSlides) return;
            
            currentSlide = indice;
            const track = document.getElementById('carruselTrack');
            const translateX = -indice * 100;
            track.style.transform = `translateX(${translateX}%)`;
            
            // Actualizar indicadores
            actualizarIndicadores();
            
            // Mostrar/ocultar botones seg√∫n la posici√≥n
            const prevBtn = document.getElementById('carruselPrev');
            const nextBtn = document.getElementById('carruselNext');
            
            // Solo ocultar el bot√≥n prev si est√° dentro del carrusel
            if (prevBtn && prevBtn.closest('.carrusel-container')) {
                prevBtn.style.display = indice === 0 ? 'none' : 'block';
            }
            
            // No ocultar el bot√≥n next ya que est√° fuera del carrusel
            // nextBtn.style.display = indice === totalSlides - 1 ? 'none' : 'block';
        }

        function actualizarIndicadores() {
            const indicadoresContainer = document.getElementById('indicadoresPagina');
            indicadoresContainer.innerHTML = '';
            
            // Limitar a m√°ximo 10 indicadores para evitar desbordamiento
            const maxIndicators = Math.min(totalSlides, 10);
            for (let i = 0; i < maxIndicators; i++) {
                const indicador = document.createElement('div');
                // Hacer indicadores circulares: si currentSlide > 9, mostrar activo en posici√≥n (currentSlide % 10)
                const activeIndicator = currentSlide >= 10 ? (currentSlide % 10) : currentSlide;
                indicador.className = `indicador ${i === activeIndicator ? 'activo' : ''}`;
                indicador.onclick = () => mostrarSlide(i);
                indicadoresContainer.appendChild(indicador);
            }
        }



        function loadLiveMatches() {
            const liveMatches = allMatches.filter(match => getMatchStatus(match) === 'live');
            currentMatches = liveMatches;
            displayMatches(liveMatches);
            showNotification(`${liveMatches.length} partidos en vivo encontrados`, 'success');
        }

        function loadSport(sport) {
            loadMatches(sport);
        }

        function filterByStatus(status, event = null) {
            currentFilter = status;
            
            // Update filter buttons
            document.querySelectorAll('.vertical-filter-btn').forEach(btn => btn.classList.remove('active'));
            
            // Solo agregar clase active si hay un evento (click del usuario)
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Si no hay evento, buscar el bot√≥n correspondiente y activarlo
                const liveButton = document.querySelector(`[onclick*="filterByStatus('live')"]`);
                if (liveButton && status === 'live') {
                    liveButton.classList.add('active');
                }
            }
            
            let filteredMatches = [];
            
            if (status === 'live') {
                // Para partidos en vivo: usar la funci√≥n getMatchStatus pero con filtro manual adicional
                const now = new Date();
                filteredMatches = allMatches.filter(match => {
                    // Primero verificar si getMatchStatus dice que est√° en vivo
                    const isLiveByStatus = getMatchStatus(match) === 'live';
                    
                    if (!isLiveByStatus) return false;
                    
                    // Si no tiene tiempo, incluirlo si getMatchStatus dice que est√° en vivo
                    if (!match.time) return true;
                    
                    const matchTime = new Date(match.time);
                    const timeDiff = now - matchTime;
                    const hoursDiff = timeDiff / (1000 * 60 * 60);
                    
                    // Solo partidos que empezaron hace menos de 2 horas
                    return hoursDiff >= 0 && hoursDiff <= 2;
                });
                
                // Ordenar por horario (m√°s recientes primero)
                filteredMatches.sort((a, b) => {
                    if (!a.time && !b.time) return 0;
                    if (!a.time) return 1;
                    if (!b.time) return -1;
                    
                    const timeA = new Date(a.time);
                    const timeB = new Date(b.time);
                    return timeB - timeA; // Orden descendente (m√°s reciente primero)
                });
                
                console.log(`üî¥ Partidos en vivo (√∫ltimas 2 horas): ${filteredMatches.length}`);
                
                // Debug: mostrar todos los partidos y su estado
                console.log('üîç Debug - Todos los partidos y su estado:');
                allMatches.slice(0, 10).forEach((match, index) => {
                    const status = getMatchStatus(match);
                    const timeStr = match.time ? new Date(match.time).toLocaleString() : 'Sin tiempo';
                    console.log(`  ${index + 1}. ${match.title} - ${timeStr} -> Estado: ${status}`);
                });
                
                filteredMatches.forEach((match, index) => {
                    const timeStr = match.time ? new Date(match.time).toLocaleString() : 'Sin tiempo';
                    console.log(`  ${index + 1}. ${match.title} - ${timeStr}`);
                });
                
            } else {
                // Para otros estados: usar la funci√≥n getMatchStatus normal
                filteredMatches = allMatches.filter(match => getMatchStatus(match) === status);
                
                // Ordenar por horario (ascendente - m√°s temprano primero)
                filteredMatches.sort((a, b) => {
                    if (!a.time && !b.time) return 0;
                    if (!a.time) return 1;
                    if (!b.time) return -1;
                    
                    const timeA = new Date(a.time);
                    const timeB = new Date(b.time);
                    return timeA - timeB; // Orden ascendente
                });
            }
            
            currentMatches = filteredMatches;
            displayMatches(filteredMatches);
            
            showNotification(`${filteredMatches.length} partidos ${status}`, 'success');
        }

        function filterByLeague(leagueName, event = null) {
            // Update filter buttons
            document.querySelectorAll('.vertical-filter-btn').forEach(btn => btn.classList.remove('active'));
            
            // Solo agregar clase active si hay un evento (click del usuario)
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            let filteredMatches = [];
            
            // Mostrar todos los partidos sin filtrar
            if (leagueName.toLowerCase() === 'mls') {
                filteredMatches = allMatches;
                console.log(`üîç Mostrando todos los partidos: ${filteredMatches.length} partidos disponibles`);
            } else {
                // Filtro normal por nombre de liga
                filteredMatches = allMatches.filter(match => {
                    const matchLeague = match.league || match.competition || match.tournament || match.event || match.category || '';
                    return matchLeague.toLowerCase().includes(leagueName.toLowerCase());
                });
            }
            
            currentMatches = filteredMatches;
            displayMatches(filteredMatches);
            
            showNotification(`${filteredMatches.length} partidos de ${leagueName} encontrados`, 'success');
        }

        function showAllLeagues() {
            const leagues = new Set();
            allMatches.forEach(match => {
                const league = match.league || match.competition || match.tournament || match.event || match.category || 'Sin Liga';
                leagues.add(league);
            });
            
            const leaguesList = Array.from(leagues).sort();
            const leaguesText = leaguesList.join('\n‚Ä¢ ');
            
            // Mostrar informaci√≥n de MLS
            let mlsInfo = '';
            if (mlsTeams && mlsTeams.length > 0) {
                mlsInfo = `\n\n‚öΩ Equipos MLS cargados (${mlsTeams.length}):\n‚Ä¢ ${mlsTeams.map(t => t.name).join('\n‚Ä¢ ')}`;
            }
            
            alert(`üìä Ligas disponibles (${leagues.size}):\n\n‚Ä¢ ${leaguesText}${mlsInfo}`);
            
            // Tambi√©n mostrar en consola para m√°s detalles
            console.log('üèÜ Ligas disponibles:', leaguesList);
            console.log('‚öΩ Equipos MLS:', mlsTeams);
            
            // Contar partidos por liga
            const leagueCounts = {};
            allMatches.forEach(match => {
                const league = match.league || match.competition || match.tournament || match.event || match.category || 'Sin Liga';
                leagueCounts[league] = (leagueCounts[league] || 0) + 1;
            });
            
            console.log('üìà Partidos por liga:', leagueCounts);
            
            // Mostrar partidos de MLS
            const mlsMatches = allMatches.filter(match => isMLSMatch(match));
            console.log('‚öΩ Partidos de MLS encontrados:', mlsMatches.length);
            mlsMatches.forEach(match => {
                console.log(`  - ${match.teams ? JSON.stringify(match.teams) : 'Sin equipos'}`);
            });
        }

        async function showStreams(matchId, matchTitle) {
            const modal = document.getElementById('streamsModal');
            const modalTitle = document.getElementById('modalTitle');
            const streamsList = document.getElementById('streamsList');
            
            modalTitle.textContent = `Streams - ${matchTitle}`;
            streamsList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-secondary);">Cargando streams...</div>';
            
            modal.style.display = 'block';
            
            try {
                const match = allMatches.find(m => m.id === matchId);
                if (!match || !match.sources) {
                    streamsList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-secondary);">No hay streams disponibles</div>';
                    return;
                }
                
                let streamsHTML = '';
                
                for (const source of match.sources) {
                    try {
                        const response = await fetch(`https://streamed.pk/api/stream/${source.source}/${source.id}`);
                        const streams = await response.json();
                        
                        if (streams && streams.length > 0) {
                            streams.forEach(stream => {
                                streamsHTML += `
                                    <div class="stream-item">
                                        <div class="stream-info">
                                            <span class="stream-quality">${stream.hd ? 'HD' : 'SD'}</span>
                                            <span class="stream-source">${stream.language || source.source}</span>
                                            <span style="color: var(--text-muted); font-size: 0.75rem;">#${stream.streamNo}</span>
                                        </div>
                                        <div class="stream-actions">
                                            <button class="stream-btn btn-embed" onclick="openStream('${stream.embedUrl}')">
                                                üì∫ Embed
                                            </button>
                                            <button class="stream-btn btn-copy" onclick="copyStreamUrl('${stream.embedUrl}')">
                                                üìã Copiar
                                            </button>
                                        </div>
                                    </div>
                                `;
                            });
                        }
                    } catch (error) {
                        console.error(`Error loading stream for ${source.source}:`, error);
                        streamsHTML += `
                            <div class="stream-item">
                                <div class="stream-info">
                                    <span class="stream-source">${source.source}</span>
                                </div>
                                <span style="color: var(--error-color); font-size: 0.875rem;">Error</span>
                            </div>
                        `;
                    }
                }
                
                if (streamsHTML) {
                    streamsList.innerHTML = streamsHTML;
                } else {
                    streamsList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-secondary);">No hay streams disponibles</div>';
                }
                
            } catch (error) {
                console.error('Error loading streams:', error);
                streamsList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--error-color);">Error al cargar streams</div>';
            }
        }

        function closeModal() {
            document.getElementById('streamsModal').style.display = 'none';
        }

        function openStream(url) {
            if (!url || url === 'undefined') {
                showNotification('URL de stream no v√°lida', 'error');
                return;
            }
            openStreamOverlay(url, 'Stream');
        }

        function openStreamOverlay(url, title = 'Stream') {
            if (!url || url === 'undefined') {
                showNotification('URL de stream no v√°lida', 'error');
                return;
            }
            
            const overlay = document.getElementById('streamOverlay');
            const iframe = document.getElementById('streamIframe');
            const overlayTitle = document.getElementById('streamOverlayTitle');
            
            // Configurar el overlay
            overlayTitle.textContent = title;
            iframe.src = url;
            
            // Mostrar el overlay
            overlay.style.display = 'block';
            
            // Bloquear scroll del body
            document.body.style.overflow = 'hidden';
            
            console.log('üé¨ Abriendo stream en overlay:', url);
        }

        function closeStreamOverlay() {
            const overlay = document.getElementById('streamOverlay');
            const iframe = document.getElementById('streamIframe');
            
            // Ocultar el overlay
            overlay.style.display = 'none';
            
            // Limpiar el iframe
            iframe.src = '';
            
            // Restaurar scroll del body
            document.body.style.overflow = 'auto';
            
            console.log('üîí Cerrando stream overlay');
        }

        function copyStreamUrl(url) {
            if (!url || url === 'undefined') {
                showNotification('URL de stream no v√°lida', 'error');
                return;
            }
            
            navigator.clipboard.writeText(url).then(() => {
                showNotification('URL copiada al portapapeles', 'success');
            }).catch(err => {
                console.error('Error copying URL:', err);
                showNotification('Error al copiar URL', 'error');
            });
        }

        async function openBestStream(matchId, matchTitle) {
            try {
                console.log('üéØ Abriendo mejor stream para:', matchTitle);
                
                const match = allMatches.find(m => m.id === matchId);
                console.log('üîç Match encontrado:', match);
                console.log('üîç Sources del match:', match?.sources);
                
                if (!match || !match.sources) {
                    showNotification('No hay streams disponibles', 'error');
                    return;
                }
                
                let bestStream = null;
                let maxViewers = 0;
                let spanishStream = null;
                let allStreams = [];
                
                // Buscar el stream con m√°s espectadores, priorizando espa√±ol
                for (const source of match.sources) {
                    try {
                        const response = await fetch(`https://streamed.pk/api/stream/${source.source}/${source.id}`);
                        const streams = await response.json();
                        
                        if (streams && streams.length > 0) {
                            streams.forEach(stream => {
                                allStreams.push(stream);
                                
                                // Priorizar streams en espa√±ol
                                const language = (stream.language || '').toLowerCase();
                                const embedUrl = (stream.embedUrl || '').toLowerCase();
                                const isSpanish = language === 'spanish' || embedUrl.includes('spanish');
                                
                                console.log(`üîç Stream ${stream.streamNo}: language="${language}", embedUrl="${embedUrl}", isSpanish=${isSpanish}`);
                                
                                if (isSpanish && !spanishStream) {
                                    spanishStream = stream;
                                    console.log('‚úÖ Encontrado stream en espa√±ol:', stream);
                                }
                                
                                // Buscar el stream con m√°s espectadores
                                if (stream.viewers && stream.viewers > maxViewers) {
                                    maxViewers = stream.viewers;
                                    bestStream = stream;
                                }
                            });
                        }
                    } catch (error) {
                        console.error(`Error loading stream for ${source.source}:`, error);
                    }
                }
                
                console.log(`üìä Total streams encontrados: ${allStreams.length}`);
                console.log(`üá™üá∏ Stream en espa√±ol encontrado:`, spanishStream);
                console.log(`üë• Stream con m√°s espectadores:`, bestStream);
                
                // Prioridad: 1) Espa√±ol, 2) Stream con espectadores, 3) Cualquier stream disponible
                let finalStream = spanishStream;
                if (!finalStream && bestStream && bestStream.viewers > 0) {
                    finalStream = bestStream;
                }
                if (!finalStream) {
                    // Usar cualquier stream disponible (el primero que encuentre)
                    finalStream = allStreams[0] || bestStream;
                }
                
                if (finalStream && finalStream.embedUrl) {
                    console.log('‚úÖ Abriendo stream:', finalStream.embedUrl);
                    openStreamOverlay(finalStream.embedUrl, matchTitle);
                } else {
                    showNotification('No se encontr√≥ un stream v√°lido', 'error');
                }
                
            } catch (error) {
                console.error('Error opening best stream:', error);
                showNotification('Error al abrir stream', 'error');
            }
        }

        function showMatchDetails(matchId) {
            const match = allMatches.find(m => m.id === matchId);
            if (match) {
                const details = JSON.stringify(match, null, 2);
                alert(`Detalles del partido:\n\n${details}`);
            }
        }

        // Close modal when clicking outside
        document.getElementById('streamsModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });

        // Funci√≥n para cargar partidos SOLO de Champions League desde ESPN API
        async function loadChampionsLeagueMatches() {
            try {
                console.log('üîç Cargando partidos SOLO de Champions League desde ESPN API...');
                
                // Generar fechas din√°micas (hoy y pr√≥ximos 7 d√≠as)
                const fechas = [];
                const hoy = new Date();
                for (let i = 0; i < 7; i++) {
                    const fecha = new Date(hoy);
                    fecha.setDate(hoy.getDate() + i);
                    const fechaStr = fecha.toISOString().split('T')[0].replace(/-/g, '');
                    fechas.push(fechaStr);
                }
                
                let championsMatches = [];
                
                for (const fecha of fechas) {
                    try {
                        const response = await fetch(`https://site.api.espn.com/apis/site/v2/sports/soccer/uefa.champions/scoreboard?dates=${fecha}&limit=50`);
                        if (response.ok) {
                            const data = await response.json();
                            console.log(`üîç Datos de ESPN para ${fecha}:`, {count: (data.events||[]).length});
                            if (data.events && Array.isArray(data.events)) {
                                championsMatches = championsMatches.concat(data.events);
                            }
                        } else {
                            console.log(`‚ö†Ô∏è Error HTTP ${response.status} para ${fecha}`);
                        }
                    } catch (error) {
                        console.log(`‚ö†Ô∏è Error cargando fecha ${fecha}:`, error.message);
                    }
                }
                
                console.log(`üèÜ Total de partidos SOLO de Champions League encontrados (ESPN): ${championsMatches.length}`);
                
                // Crear set de equipos a partir del scoreboard (no standings para evitar ruido si no hay jornada)
                const championsTeams = new Set();
                championsMatches.forEach(match => {
                    if (match && match.name) {
                        const parts = match.name.split(' vs ');
                        parts.forEach(t => championsTeams.add((t||'').trim().toLowerCase()));
                    }
                });
                console.log('üèÜ Equipos de Champions (ESPN scoreboard):', championsTeams.size);
                
                // Filtrar partidos de Streamed: criterios estrictos
                const streamedChampionsMatches = allMatches.filter(match => {
                    if (!match || !match.title) return false;
                    const title = match.title.toLowerCase();
                    const isEuropa = title.includes('europa league');
                    const isConference = title.includes('conference league');
                    const hasChampionsLabel = title.includes('champions league') || title.includes('uefa champions');
                    
                    if (isEuropa || isConference) return false;
                    
                    // Si ESPN tiene 0 eventos para este per√≠odo, no intentar inferir: retornar solo si etiqueta expl√≠cita
                    if (championsMatches.length === 0) {
                        return hasChampionsLabel;
                    }
                    
                    // Con ESPN: permitir etiqueta expl√≠cita, o cruce por equipos del scoreboard
                    if (hasChampionsLabel) return true;
                    
                    // Extraer equipos del t√≠tulo y validar ambos en set de ESPN
                    const parsed = extractTeamsFromTitle(match.title) || [];
                    if (parsed.length === 2) {
                        const a = parsed[0].toLowerCase();
                        const b = parsed[1].toLowerCase();
                        const inA = Array.from(championsTeams).some(ct => a.includes(ct) || ct.includes(a));
                        const inB = Array.from(championsTeams).some(ct => b.includes(ct) || ct.includes(b));
                        if (inA && inB) return true;
                    }
                    return false;
                });
                
                console.log(`‚öΩ Partidos SOLO de Champions League identificados en Streamed (estricto): ${streamedChampionsMatches.length}`);
                streamedChampionsMatches.forEach(match => console.log(`  - ${match.title}`));
                
                return {
                    championsMatches,
                    streamedChampionsMatches,
                    championsTeams: Array.from(championsTeams)
                };
                
            } catch (error) {
                console.error('Error cargando partidos de Champions League:', error);
                return { championsMatches: [], streamedChampionsMatches: [], championsTeams: [] };
            }
        }

        // Funci√≥n para filtrar por Champions League
        function filterByChampionsLeague() {
            // Usar clasificaci√≥n general por t√≠tulo para determinar competici√≥n y limitar a HOY
            const championsToday = allMatches.filter(m => {
                const comp = computeNormalizedCompetition(m);
                return comp === 'Champions League' && isTodayLocal(Number(m.date));
            });

            currentMatches = championsToday;
            displayMatches(currentMatches);
        }

        // Funci√≥n de debug para Champions League
        function debugChampionsLeague() {
            console.log('üîç DEBUG: Iniciando debug de Champions League...');
            console.log('üîç Total de partidos cargados:', allMatches.length);
            
            // Mostrar todos los partidos que contengan "brugge" o "rangers"
            const partidosRelevantes = allMatches.filter(match => {
                if (!match.title) return false;
                const title = match.title.toLowerCase();
                return title.includes('brugge') || title.includes('rangers') || title.includes('benfica') || title.includes('fenerbahce');
            });
            
            // Buscar espec√≠ficamente "Club Brugge vs Rangers"
            const bruggeRangers = allMatches.filter(match => {
                if (!match.title) return false;
                const title = match.title.toLowerCase();
                return title.includes('club brugge') && title.includes('rangers');
            });
            
            console.log('üîç Partido espec√≠fico Club Brugge vs Rangers encontrado:', bruggeRangers.length);
            bruggeRangers.forEach(match => {
                console.log(`  - ${match.title}`);
            });
            
            console.log('üîç Partidos relevantes encontrados:', partidosRelevantes.length);
            partidosRelevantes.forEach(match => {
                console.log(`  - ${match.title}`);
            });
            
            // Ejecutar la funci√≥n normal de Champions League
            loadChampionsLeagueMatches().then(result => {
                console.log('üîç DEBUG: Resultado de loadChampionsLeagueMatches:', result);
            });
        }

        // Ponderaciones
        const COMPETITION_WEIGHTS = {
            'Champions League': 1000,
            'Europa League': 700,
            'Conference League': 500,
            'Premier League': 650,
            'LaLiga': 600,
            'Serie A': 550,
            'Bundesliga': 500,
            'Ligue 1': 450,
            'FA Cup': 400,
            'Carabao Cup': 350,
            'F√∫tbol': 100
        };

        const BIG_TEAMS = [
            'real madrid','barcelona','atl√©tico','atletico','sevilla','valencia','villarreal',
            'manchester city','manchester united','chelsea','arsenal','liverpool','tottenham',
            'bayern','borussia dortmund','psg','paris saint-germain','marseille','lyon',
            'juventus','inter','milan','ac milan','napoli','roma'
        ];

        function computeMatchScore(match) {
            let score = 0;
            const comp = computeNormalizedCompetition(match) || 'F√∫tbol';
            score += COMPETITION_WEIGHTS[comp] || 0;
            
            // Equipos grandes
            const title = (match.title || '').toLowerCase();
            BIG_TEAMS.forEach(t => { if (title.includes(t)) score += 120; });
            
            // En vivo/scheduled como desempate
            const st = getMatchStatus(match);
            if (st === 'live') score += 80; else if (st === 'scheduled') score += 40;
            
            // N√∫mero de fuentes
            if (Array.isArray(match.sources)) score += match.sources.length * 10;
            
            return score;
        }

        function getPopularMatches(matches, limit = 5) {
            if (!matches || matches.length === 0) return [];
            
            const ranked = matches.map(m => ({ m, s: computeMatchScore(m) }))
                                  .sort((a,b) => b.s - a.s)
                                  .slice(0, limit)
                                  .map(x => x.m);
            return ranked;
        }

        function getCategory(match) {
            function pickString(val) {
                if (!val) return '';
                if (typeof val === 'string') return val;
                if (typeof val === 'number') return String(val);
                if (Array.isArray(val)) {
                    // tomar primer string √∫til del array
                    for (const item of val) {
                        const s = pickString(item);
                        if (s) return s;
                    }
                    return '';
                }
                if (typeof val === 'object') {
                    // campos comunes: name, title, displayName, caption
                    const keys = ['name','title','displayName','caption','competition','league'];
                    for (const k of keys) {
                        if (val[k]) {
                            const s = pickString(val[k]);
                            if (s) return s;
                        }
                    }
                }
                return '';
            }

            const candidates = [
                match.competition,
                match.tournament,
                match.event,
                match.category,
                match.league,
                match.sport,
                match.metadata && match.metadata.competition,
                match.details && match.details.league
            ];

            let raw = '';
            for (const c of candidates) {
                raw = pickString(c);
                if (raw && raw.trim().length > 0) break;
            }
            if (!raw) return '';

            let val = raw.toString().trim();
            const lower = val.toLowerCase();

            // Omitir t√©rminos gen√©ricos
            const generics = ['football','soccer','deportes','sports','futbol','f√∫tbol'];
            if (generics.includes(lower)) return '';

            // Mapear competiciones comunes a etiquetas est√°ndar/espa√±ol
            const mappings = [
                { k: 'uefa champions', v: 'Champions League' },
                { k: 'champions league', v: 'Champions League' },
                { k: 'uefa europa', v: 'Europa League' },
                { k: 'europa league', v: 'Europa League' },
                { k: 'conference league', v: 'Conference League' },
                { k: 'premier league', v: 'Premier League' },
                { k: 'la liga', v: 'LaLiga' },
                { k: 'serie a', v: 'Serie A' },
                { k: 'bundesliga', v: 'Bundesliga' },
                { k: 'ligue 1', v: 'Ligue 1' },
                { k: 'carabao cup', v: 'Carabao Cup' },
                { k: 'efl cup', v: 'Carabao Cup' },
                { k: 'fa cup', v: 'FA Cup' },
                { k: 'coppa italia', v: 'Coppa Italia' },
                { k: 'copa del rey', v: 'Copa del Rey' },
                { k: 'dfb-pokal', v: 'DFB-Pokal' }
            ];
            for (const m of mappings) {
                if (lower.includes(m.k)) return m.v;
            }

            // Capitalizaci√≥n limpia
            val = val.replace(/\s+/g, ' ').trim();
            val = val.split(' ').map(w => w.length > 2 ? w[0].toUpperCase() + w.slice(1) : w.toLowerCase()).join(' ');
            return val;
        }

        // Normalizar t√≠tulos a espa√±ol para coincidencias (equipos/competiciones)
        function normalizeSpanishTitle(title) {
            if (!title || typeof title !== 'string') return '';
            let t = title;
            // Mapeos comunes de equipos/competiciones a espa√±ol
            const replacements = [
                // Competici√≥n
                { from: /uefa\s*champions\s*league/gi, to: 'liga de campeones' },
                { from: /champions\s*league/gi, to: 'liga de campeones' },
                { from: /uefa\s*europa\s*league/gi, to: 'liga europa' },
                { from: /europa\s*league/gi, to: 'liga europa' },
                { from: /conference\s*league/gi, to: 'conference league' },
                // Equipos
                { from: /red\s*star\s*belgrade/gi, to: 'estrella roja' },
                { from: /crvena\s*zvezda/gi, to: 'estrella roja' },
                { from: /bodo\/?glimt/gi, to: 'bod√∏\/glimt' }
            ];
            replacements.forEach(r => { t = t.replace(r.from, r.to); });
            return t;
        }

        function getCompetitionFromTitle(title) {
            if (!title || typeof title !== 'string') return '';
            // Asegurar coincidencias en espa√±ol primero
            const normalized = normalizeSpanishTitle(title);
            const t = normalized.trim();
            // Si viene con prefijo "Competici√≥n: TeamA vs TeamB"
            const idx = t.indexOf(':');
            if (idx > 0) {
                const prefix = t.slice(0, idx).toLowerCase();
                if (prefix.includes('liga de campeones')) return 'Champions League';
                if (prefix.includes('liga europa')) return 'Europa League';
                if (prefix.includes('conference league')) return 'Conference League';
                if (prefix.includes('premier league')) return 'Premier League';
                if (prefix.includes('la liga')) return 'LaLiga';
                if (prefix.includes('serie a')) return 'Serie A';
                if (prefix.includes('bundesliga')) return 'Bundesliga';
                if (prefix.includes('ligue 1')) return 'Ligue 1';
                if (prefix.includes('carabao cup') || prefix.includes('efl cup')) return 'Carabao Cup';
                if (prefix.includes('fa cup')) return 'FA Cup';
            }
            // Detecci√≥n dentro del t√≠tulo completo
            const lt = t.toLowerCase();
            if (lt.includes('liga de campeones')) return 'Champions League';
            if (lt.includes('liga europa')) return 'Europa League';
            if (lt.includes('conference league')) return 'Conference League';
            if (lt.includes('premier league')) return 'Premier League';
            if (lt.includes('la liga')) return 'LaLiga';
            if (lt.includes('serie a')) return 'Serie A';
            if (lt.includes('bundesliga')) return 'Bundesliga';
            if (lt.includes('ligue 1')) return 'Ligue 1';
            if (lt.includes('carabao cup') || lt.includes('efl cup')) return 'Carabao Cup';
            if (lt.includes('fa cup')) return 'FA Cup';
            return '';
        }

        // Cache de competiciones normalizadas por partido
        const competitionCache = new Map();
        // Overrides provenientes del diario externo (ftvhd)
        const competitionOverride = new Map();

        async function fetchDiaryToday() {
            try {
                const today = new Date().toISOString().slice(0,10); // yyyy-mm-dd
                const res = await fetch('https://ftvhd.com/diaries.json');
                const json = await res.json();
                const items = Array.isArray(json?.data) ? json.data : [];
                // Quedarse con eventos de hoy
                const todayEvents = items.filter(it => it?.attributes?.date_diary === today);
                return todayEvents.map(it => {
                    const desc = it.attributes?.diary_description || '';
                    const hour = it.attributes?.diary_hour || '';
                    return { description: desc, hour, competition: getCompetitionFromTitle(desc) };
                });
            } catch (e) {
                console.log('ftvhd diary error:', e.message);
                return [];
            }
        }

        function teamsFromString(title) {
            const parsed = extractTeamsFromTitle(title || '') || [];
            if (parsed.length === 2) {
                return [ normalizeTeamSpanish(limpiarNombreEquipo(parsed[0])).toLowerCase(),
                         normalizeTeamSpanish(limpiarNombreEquipo(parsed[1])).toLowerCase() ];
            }
            return [];
        }

        function teamsFromStringRaw(title) {
            const parsed = extractTeamsFromTitle(title || '') || [];
            if (parsed.length === 2) {
                return [ (parsed[0] || '').trim().toLowerCase(), (parsed[1] || '').trim().toLowerCase() ];
            }
            return [];
        }

        function normalizeForMatch(name) {
            if (!name) return '';
            // a min√∫sculas, quitar acentos/diacr√≠ticos, quitar s√≠mbolos y espacios extra
            const s = name.toLowerCase()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .replace(/[^a-z0-9\/\s]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            // alias b√°sicos
            const aliases = [
                { r: /crvena zvezda|red star belgrade|estrella roja/g, to: 'estrella roja' },
                { r: /bod[o√∏] \/? glimt|bodo \/? glimt|bodo glimt/g, to: 'bodo glimt' },
                { r: /paphos/g, to: 'pafos' }
            ];
            let out = s;
            aliases.forEach(a => { out = out.replace(a.r, a.to); });
            return out;
        }

        function parseDiaryHourToTodayTime(hhmmss) {
            try {
                const [hh, mm, ss] = (hhmmss || '00:00:00').split(':').map(x => parseInt(x, 10) || 0);
                const now = new Date();
                const d = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hh, mm, ss, 0);
                return d.getTime();
            } catch (_) { return 0; }
        }

        function diaryAssignCompetitionsForToday(matches, diaryEvents) {
            if (!Array.isArray(matches) || matches.length === 0 || !Array.isArray(diaryEvents)) return;
            // Construir lista de eventos con pares de equipos (tal como vienen)
            const diaryParsed = diaryEvents.map(ev => {
                const t = ev.description || '';
                const [aRaw,bRaw] = teamsFromStringRaw(t);
                const a = normalizeForMatch(aRaw);
                const b = normalizeForMatch(bRaw);
                const ts = parseDiaryHourToTodayTime(ev.hour);
                return { a, b, comp: ev.competition, ts };
            }).filter(x => x.a && x.b && x.comp);
 
            matches.forEach(m => {
                const isToday = isTodayLocal(Number(m.date));
                if (!isToday) return;
                const [maRaw, mbRaw] = teamsFromStringRaw(m.title || '');
                const ma = normalizeForMatch(maRaw);
                const mb = normalizeForMatch(mbRaw);
                if (!ma || !mb) return;
                const ms = Number(m.date);
                // Coincidencia si ambos equipos aparecen (contiene/incluye) en alguna entrada del diario (sin normalizaci√≥n)
                const hit = diaryParsed.find(ev => {
                    const aMatch = ma.includes(ev.a) || ev.a.includes(ma);
                    const bMatch = mb.includes(ev.b) || ev.b.includes(mb);
                    const aMatchAlt = ma.includes(ev.b) || ev.b.includes(ma);
                    const bMatchAlt = mb.includes(ev.a) || ev.a.includes(mb);
                    const teamOk = (aMatch && bMatch) || (aMatchAlt && bMatchAlt);
                    if (!teamOk) return false;
                    // tolerancia horaria ¬±90 minutos si el diario trae hora
                    if (ev.ts && ms) {
                        const diffMin = Math.abs(ms - ev.ts) / 60000;
                        return diffMin <= 90;
                    }
                    return true;
                });
                if (hit && hit.comp) {
                    const key = m.id || m.title || JSON.stringify(m).slice(0,100);
                    competitionOverride.set(key, hit.comp);
                }
            });
        }

        function computeNormalizedCompetition(match) {
            if (!match) return '';
            const key = match.id || match.title || JSON.stringify(match).slice(0,100);
            // Primero, si hay override del diario, usarlo
            if (competitionOverride.has(key)) return competitionOverride.get(key) || '';
            if (competitionCache.has(key)) return competitionCache.get(key) || '';
            
            // 1) Intentar desde t√≠tulo (normalizado a espa√±ol para coincidencias)
            const derivedTitle = normalizeSpanishTitle(match.title || '');
            let comp = getCompetitionFromTitle(derivedTitle);
            // 2) Si no, intentar categor√≠a no gen√©rica
            if (!comp) comp = getCategory(match);
            
            competitionCache.set(key, comp || '');
            return comp || '';
        }

        function getDisplayCategory(match) {
            console.log('üîç getDisplayCategory llamado con:', match.title);
            
            // 1. Extraer categor√≠a espec√≠fica del t√≠tulo del partido
            if (match.title) {
                // Extraer categor√≠a (lo que est√° antes de ":")
                const categoryMatch = match.title.match(/^([^:]+):\s*(.+)$/);
                console.log('üîç categoryMatch:', categoryMatch);
                
                if (categoryMatch) {
                    let category = categoryMatch[1].trim();
                    console.log('üîç Categor√≠a extra√≠da del t√≠tulo:', category);
                    
                    // Limpiar categor√≠as comunes
                    if (category.includes('UEFA Champions League')) {
                        console.log('‚úÖ Retornando: Champions League');
                        return 'Champions League';
                    } else if (category.includes('UEFA Europa League')) {
                        console.log('‚úÖ Retornando: Europa League');
                        return 'Europa League';
                    } else if (category.includes('Premier League')) {
                        console.log('‚úÖ Retornando: Premier League');
                        return 'Premier League';
                    } else if (category.includes('La Liga')) {
                        console.log('‚úÖ Retornando: La Liga');
                        return 'La Liga';
                    } else if (category.includes('Serie A')) {
                        console.log('‚úÖ Retornando: Serie A');
                        return 'Serie A';
                    } else if (category.includes('Bundesliga')) {
                        console.log('‚úÖ Retornando: Bundesliga');
                        return 'Bundesliga';
                    } else if (category.includes('Ligue 1')) {
                        console.log('‚úÖ Retornando: Ligue 1');
                        return 'Ligue 1';
                    } else if (category.includes('DFB Pokal')) {
                        console.log('‚úÖ Retornando: DFB Pokal');
                        return 'DFB Pokal';
                    } else if (category.includes('Copa Argentina')) {
                        console.log('‚úÖ Retornando: Copa Argentina');
                        return 'Copa Argentina';
                    } else if (category.includes('Serie B')) {
                        console.log('‚úÖ Retornando: Serie B');
                        return 'Serie B';
                    } else if (category.includes('CONCACAF')) {
                        console.log('‚úÖ Retornando: CONCACAF');
                        return 'CONCACAF';
                    } else if (category.includes('USL League')) {
                        console.log('‚úÖ Retornando: USL League');
                        return 'USL League';
                    } else if (category.includes('League Cup')) {
                        console.log('‚úÖ Retornando: League Cup');
                        return 'League Cup';
                    }
                    
                    // Si no coincide con ninguna categor√≠a conocida, devolver la original
                    console.log('‚úÖ Retornando categor√≠a original:', category);
                    return category;
                }
            }
            
            // 2. Buscar en otros campos del objeto match
            console.log('üîç Buscando en otros campos del match:', match);
            
            // Buscar en category, competition, tournament, league, etc.
            const possibleFields = ['category', 'competition', 'tournament', 'league', 'event', 'sport'];
            for (const field of possibleFields) {
                if (match[field]) {
                    console.log(`üîç Encontrado en ${field}:`, match[field]);
                    let category = String(match[field]).trim();
                    
                    // Limpiar categor√≠as comunes
                    if (category.includes('UEFA Champions League') || category.includes('Champions League')) {
                        console.log('‚úÖ Retornando: Champions League');
                        return 'Champions League';
                    } else if (category.includes('UEFA Europa League') || category.includes('Europa League')) {
                        console.log('‚úÖ Retornando: Europa League');
                        return 'Europa League';
                    } else if (category.includes('Premier League')) {
                        console.log('‚úÖ Retornando: Premier League');
                        return 'Premier League';
                    } else if (category.includes('La Liga')) {
                        console.log('‚úÖ Retornando: La Liga');
                        return 'La Liga';
                    } else if (category.includes('Serie A')) {
                        console.log('‚úÖ Retornando: Serie A');
                        return 'Serie A';
                    } else if (category.includes('Bundesliga')) {
                        console.log('‚úÖ Retornando: Bundesliga');
                        return 'Bundesliga';
                    } else if (category.includes('Ligue 1')) {
                        console.log('‚úÖ Retornando: Ligue 1');
                        return 'Ligue 1';
                    } else if (category.includes('DFB Pokal')) {
                        console.log('‚úÖ Retornando: DFB Pokal');
                        return 'DFB Pokal';
                    } else if (category.includes('Copa Argentina')) {
                        console.log('‚úÖ Retornando: Copa Argentina');
                        return 'Copa Argentina';
                    } else if (category.includes('Serie B')) {
                        console.log('‚úÖ Retornando: Serie B');
                        return 'Serie B';
                    } else if (category.includes('CONCACAF')) {
                        console.log('‚úÖ Retornando: CONCACAF');
                        return 'CONCACAF';
                    } else if (category.includes('USL League')) {
                        console.log('‚úÖ Retornando: USL League');
                        return 'USL League';
                    } else if (category.includes('League Cup') || category.includes('Carabao Cup')) {
                        console.log('‚úÖ Retornando: League Cup');
                        return 'League Cup';
                    }
                    
                    // Si no coincide con ninguna categor√≠a conocida, devolver la original
                    console.log('‚úÖ Retornando categor√≠a de campo:', category);
                    
                    // Convertir "football" a "F√∫tbol"
                    if (category.toLowerCase() === 'football') {
                        return 'F√∫tbol';
                    }
                    
                    return category;
                }
            }
            
            // 3. Preferir competici√≥n normalizada del sistema como fallback
            const comp = computeNormalizedCompetition(match);
            console.log('üîç computeNormalizedCompetition result:', comp);
            if (comp) return comp;
            
            // 4. Detectar categor√≠a basada en equipos conocidos
            if (match.title) {
                const title = match.title.toLowerCase();
                console.log('üîç Detectando categor√≠a por equipos en:', title);
                
                // Champions League teams
                if (title.includes('celtic') || title.includes('qarabag') || title.includes('ferencvarosi') || 
                    title.includes('benfica') || title.includes('fenerbahce') || title.includes('sturm graz') ||
                    title.includes('bodo') || title.includes('glimt') || title.includes('pafos') || 
                    title.includes('red star') || title.includes('crvena zvezda')) {
                    console.log('‚úÖ Detectado Champions League por equipos');
                    return 'Champions League';
                }
                
                // Premier League teams
                if (title.includes('chelsea') || title.includes('fulham') || title.includes('manchester united') ||
                    title.includes('burnley') || title.includes('wolves') || title.includes('west ham') ||
                    title.includes('tottenham') || title.includes('bournemouth') || title.includes('sunderland') ||
                    title.includes('brentford') || title.includes('leeds') || title.includes('newcastle') ||
                    title.includes('nottingham') || title.includes('brighton') || title.includes('manchester city') ||
                    title.includes('liverpool') || title.includes('arsenal') || title.includes('aston villa') ||
                    title.includes('crystal palace') || title.includes('everton')) {
                    console.log('‚úÖ Detectado Premier League por equipos');
                    return 'Premier League';
                }
                
                // Europa League teams
                if (title.includes('kups') || title.includes('midtjylland') || title.includes('sigma olomouc') ||
                    title.includes('malmo') || title.includes('samsunspor') || title.includes('panathinaikos') ||
                    title.includes('ludogorets') || title.includes('shkendija') || title.includes('paok') ||
                    title.includes('rijeka') || title.includes('utrecht') || title.includes('zrinjski') ||
                    title.includes('genk') || title.includes('lech poznan') || title.includes('dynamo kyiv') ||
                    title.includes('maccabi') || title.includes('young boys') || title.includes('slovan') ||
                    title.includes('fcsb') || title.includes('aberdeen') || title.includes('braga') ||
                    title.includes('lincoln red imps')) {
                    console.log('‚úÖ Detectado Europa League por equipos');
                    return 'Europa League';
                }
                
                // DFB Pokal teams
                if (title.includes('bayern') || title.includes('stuttgart') || title.includes('eintracht')) {
                    console.log('‚úÖ Detectado DFB Pokal por equipos');
                    return 'DFB Pokal';
                }
                
                // Copa Argentina teams
                if (title.includes('river plate') || title.includes('union santa fe')) {
                    console.log('‚úÖ Detectado Copa Argentina por equipos');
                    return 'Copa Argentina';
                }
                
                // Serie B teams
                if (title.includes('remo') || title.includes('criciuma')) {
                    console.log('‚úÖ Detectado Serie B por equipos');
                    return 'Serie B';
                }
                
                // CONCACAF teams
                if (title.includes('moca') || title.includes('mount pleasant')) {
                    console.log('‚úÖ Detectado CONCACAF por equipos');
                    return 'CONCACAF';
                }
                
                // USL League teams
                if (title.includes('forward madison') || title.includes('texoma') || title.includes('knoxville') ||
                    title.includes('naples')) {
                    console.log('‚úÖ Detectado USL League por equipos');
                    return 'USL League';
                }
                
                // African teams
                if (title.includes('madagascar') || title.includes('sudan') || title.includes('morocco') ||
                    title.includes('senegal') || title.includes('polokwane') || title.includes('durban') ||
                    title.includes('richards bay') || title.includes('chippa') || title.includes('stellenbosch') ||
                    title.includes('marumo') || title.includes('orlando pirates') || title.includes('orbit') ||
                    title.includes('ts galaxy') || title.includes('siwelele')) {
                    console.log('‚úÖ Detectado F√∫tbol Africano por equipos');
                    return 'F√∫tbol Africano';
                }
                
                // Mexican teams
                if (title.includes('cruz azul') || title.includes('toluca') || title.includes('pachuca') ||
                    title.includes('atlas') || title.includes('guadalajara') || title.includes('monterrey') ||
                    title.includes('queretaro') || title.includes('tigres')) {
                    console.log('‚úÖ Detectado Liga MX por equipos');
                    return 'Liga MX';
                }
                
                // Colombian teams
                if (title.includes('bogota') || title.includes('cucuta') || title.includes('atletico junior') ||
                    title.includes('atletico fc') || title.includes('deportivo pereira') || title.includes('real cundinamarca') ||
                    title.includes('real cartagena') || title.includes('millonarios') || title.includes('cartagines') ||
                    title.includes('independiente') || title.includes('deportivo saprissa') || title.includes('motagua')) {
                    console.log('‚úÖ Detectado F√∫tbol Colombiano por equipos');
                    return 'F√∫tbol Colombiano';
                }
                
                // Caribbean teams
                if (title.includes('robinhood') || title.includes('central fc') || title.includes('weymouth wales') ||
                    title.includes('cibao')) {
                    console.log('‚úÖ Detectado F√∫tbol Caribe√±o por equipos');
                    return 'F√∫tbol Caribe√±o';
                }
            }
            
            // 5. √öltimo fallback
            console.log('‚ùå Retornando fallback: F√∫tbol');
            return 'F√∫tbol';
        }

        async function loadStreamsWithMostViewers() {
            try {
                console.log('üî• Cargando partidos ordenados por espectadores...');
                
                // Obtener todos los partidos de una vez
                const response = await fetch('https://streamed.pk/api/matches/live');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const allMatches = await response.json();
                
                if (!Array.isArray(allMatches)) {
                    throw new Error('La respuesta no es un array de partidos');
                }
                
                console.log(`üìä Procesando ${allMatches.length} partidos para ordenar por espectadores...`);
                
                // Filtrar solo partidos de f√∫tbol (filtro m√°s estricto)
                const footballMatches = allMatches.filter(match => {
                    const title = match.title?.toLowerCase() || '';
                    const category = match.category?.toLowerCase() || '';
                    
                    // EXCLUIR deportes que NO son f√∫tbol
                    const nonFootballKeywords = [
                        'tennis', 'basketball', 'basket', 'nba', 'baseball', 'mlb', 'hockey', 'nhl',
                        'volleyball', 'volley', 'rugby', 'cricket', 'golf', 'boxing', 'mma', 'ufc',
                        'wrestling', 'wwe', 'aew', 'racing', 'f1', 'formula', 'nascar', 'motogp',
                        'cycling', 'cycling', 'swimming', 'athletics', 'track', 'field', 'olympics',
                        'olympic', 'esports', 'csgo', 'lol', 'league of legends', 'dota', 'valorant',
                        'us open', 'wimbledon', 'australian open', 'french open', 'grand slam',
                        'court', 'set', 'match point', 'serve', 'ace', 'deuce', 'advantage',
                        'grandstand', 'christopher', 'alex', 'minaur', 'oconnell', 'player', 'players',
                        'singles', 'doubles', 'mixed', 'qualifying', 'main draw', 'round', 'final',
                        'semifinal', 'quarterfinal', 'robin', 'group', 'pool', 'bracket'
                    ];
                    
                    // Si contiene palabras de otros deportes, excluirlo
                    if (nonFootballKeywords.some(keyword => title.includes(keyword))) {
                        return false;
                    }
                    
                    // INCLUIR solo si es claramente f√∫tbol
                    const footballKeywords = [
                        'football', 'soccer', 'futbol', 'f√∫tbol', 'liga', 'league', 'champions', 
                        'europa', 'premier', 'bundesliga', 'serie a', 'la liga', 'ligue 1',
                        'copa', 'cup', 'uefa', 'fifa', 'world cup', 'copa del mundo',
                        'euro', 'european', 'qualifiers', 'eliminatorias', 'friendly', 'amistoso',
                        'dfb pokal', 'fa cup', 'carabao cup', 'super cup', 'community shield'
                    ];
                    
                    // Debe tener categor√≠a football O contener palabras clave de f√∫tbol
                    const isFootballByCategory = category === 'football';
                    const isFootballByKeywords = footballKeywords.some(keyword => 
                        title.includes(keyword) || category.includes(keyword)
                    );
                    
                    // Solo incluir partidos que tengan "vs" Y sean claramente de f√∫tbol
                    const hasVs = (title.includes(' vs ') || title.includes(' versus ')) && 
                                 !nonFootballKeywords.some(keyword => title.includes(keyword)) &&
                                 (isFootballByCategory || isFootballByKeywords);
                    
                    // Solo retornar true si es claramente f√∫tbol
                    return isFootballByCategory || (isFootballByKeywords && hasVs);
                });
                
                console.log(`‚öΩ Partidos de f√∫tbol encontrados: ${footballMatches.length}`);
                
                // Mostrar los primeros 5 partidos filtrados para debug
                if (footballMatches.length > 0) {
                    console.log('‚öΩ Primeros 5 partidos de f√∫tbol filtrados:');
                    footballMatches.slice(0, 5).forEach((match, index) => {
                        console.log(`  ${index + 1}. ${match.title} (${match.category})`);
                    });
                }
                
                // FILTRAR partidos por rango de tiempo (2 horas desde ahora)
                const now = new Date();
                const twoHoursFromNow = new Date(now.getTime() + (2 * 60 * 60 * 1000)); // +2 horas
                
                const timeFilteredMatches = footballMatches.filter(match => {
                    if (!match.time) return false;
                    
                    const matchTime = new Date(match.time);
                    return matchTime >= now && matchTime <= twoHoursFromNow;
                });
                
                console.log(`‚öΩ Partidos en las pr√≥ximas 2 horas: ${timeFilteredMatches.length}`);
                
                // Si no hay partidos en las pr√≥ximas 2 horas, usar los pr√≥ximos 10 partidos
                const limitedMatches = timeFilteredMatches.length > 0 ? 
                    timeFilteredMatches.slice(0, 10) : 
                    footballMatches.slice(0, 10);
                
                console.log(`‚öΩ Procesando ${limitedMatches.length} partidos seleccionados`);
                
                // Array para almacenar todos los streams con sus espectadores
                const allStreams = [];
                
                // Lista de fuentes a consultar (reducida para evitar rate limiting)
                const sources = ['alpha', 'bravo', 'echo', 'hotel'];
                
                // Procesar solo partidos de f√∫tbol limitados
                for (let i = 0; i < limitedMatches.length; i++) {
                    const match = limitedMatches[i];
                    
                    for (let j = 0; j < sources.length; j++) {
                        const source = sources[j];
                        
                        // Agregar delay de 200ms entre peticiones para evitar rate limiting
                        if (j > 0) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                        
                        try {
                            // Usar el ID espec√≠fico de la fuente si existe, sino usar el ID general
                            let sourceId = match.id;
                            
                            // Si el partido tiene sources, buscar el ID espec√≠fico para esta fuente
                            if (match.sources && Array.isArray(match.sources)) {
                                const sourceMatch = match.sources.find(s => s.source === source);
                                if (sourceMatch) {
                                    sourceId = sourceMatch.id;
                                }
                            }
                            

                            const streamResponse = await fetch(`https://streamed.pk/api/stream/${source}/${sourceId}`);
                            
                            if (streamResponse.ok) {
                                const streams = await streamResponse.json();
                                
                                if (Array.isArray(streams) && streams.length > 0) {
                                    streams.forEach(stream => {
                                        if (stream.viewers && stream.viewers > 0) {
                                            console.log(`‚úÖ Encontrado ${stream.viewers} espectadores en ${source} para ${match.title}`);
                                            allStreams.push({
                                                ...stream,
                                                matchTitle: match.title,
                                                matchId: match.id,
                                                matchCategory: match.category,
                                                matchPoster: match.poster,
                                                matchTime: match.time, // Agregar tiempo del partido original
                                                teams: match.teams // Agregar estructura teams del partido original
                                            });
                                        }
                                    });
                                }
                            } else {
                                console.log(`‚ùå Error ${streamResponse.status} en ${source} para ${match.title}`);
                            }
                        } catch (error) {
                            console.log(`‚ùå Error en ${source} para ${match.title}: ${error.message}`);
                        }
                        
                        // Agregar delay de 100ms entre peticiones para evitar rate limiting
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                // Ordenar por n√∫mero de espectadores (descendente)
                const sortedStreams = allStreams.sort((a, b) => b.viewers - a.viewers);
                
                console.log(`üî• Total streams con espectadores encontrados: ${sortedStreams.length}`);
                
                // Mostrar los top 10 streams con m√°s espectadores
                if (sortedStreams.length > 0) {
                    console.log('üî• Top streams por espectadores:');
                    sortedStreams.slice(0, 10).forEach((stream, index) => {
                        console.log(`  ${index + 1}. ${stream.matchTitle} - ${stream.source} (${stream.viewers} viewers)`);
                    });
                }
                
                // Retornar los partidos √∫nicos de los streams con m√°s espectadores
                const uniqueMatches = [];
                const seenMatchIds = new Set();
                
                for (const stream of sortedStreams) {
                    if (!seenMatchIds.has(stream.matchId)) {
                        seenMatchIds.add(stream.matchId);
                        uniqueMatches.push({
                            id: stream.matchId,
                            title: stream.matchTitle,
                            category: stream.matchCategory,
                            poster: stream.matchPoster,
                            topViewers: stream.viewers,
                            topSource: stream.source,
                            time: stream.matchTime, // Usar tiempo del partido original
                            teams: stream.teams // Agregar estructura teams si existe
                        });
                    }
                }
                
                // Filtrar solo partidos futuros o en vivo (excluir finalizados)
                const currentTime = new Date();
                const futureMatches = uniqueMatches.filter(match => {
                    if (!match.time) return true; // Si no tiene tiempo, incluirlo
                    
                    const matchTime = new Date(match.time);
                    const timeDiff = matchTime - currentTime;
                    const hoursDiff = timeDiff / (1000 * 60 * 60);
                    
                    // Solo incluir partidos que:
                    // - Est√°n en vivo (dentro de las √∫ltimas 3 horas)
                    // - Son futuros (en las pr√≥ximas 24 horas)
                    // - NO est√°n finalizados (m√°s de 3 horas atr√°s)
                    return hoursDiff >= -3 && hoursDiff <= 24;
                });
                
                // Ordenar por horario (ascendente - m√°s temprano primero)
                const sortedByTime = futureMatches.sort((a, b) => {
                    if (!a.time && !b.time) return 0;
                    if (!a.time) return 1;
                    if (!b.time) return -1;
                    
                    const timeA = new Date(a.time);
                    const timeB = new Date(b.time);
                    return timeA - timeB;
                });
                
                // Contar partidos finalizados para el log
                const finishedMatches = uniqueMatches.filter(match => {
                    if (!match.time) return false;
                    const matchTime = new Date(match.time);
                    const timeDiff = matchTime - currentTime;
                    const hoursDiff = timeDiff / (1000 * 60 * 60);
                    return hoursDiff < -3; // M√°s de 3 horas atr√°s
                });
                
                console.log(`üïê Partidos filtrados: ${uniqueMatches.length} total, ${futureMatches.length} futuros/en vivo, ${finishedMatches.length} finalizados (excluidos)`);
                console.log('üïê Partidos ordenados por horario:');
                sortedByTime.slice(0, 8).forEach((match, index) => {
                    const timeStr = match.time ? new Date(match.time).toLocaleString() : 'Sin horario';
                    console.log(`  ${index + 1}. ${match.title} - ${timeStr}`);
                });
                
                // FALLBACK: Si no hay suficientes partidos con espectadores, agregar partidos en vivo
                let finalMatches = sortedByTime.slice(0, 8);
                
                // Solo agregar fallback si realmente no hay suficientes partidos con espectadores
                if (finalMatches.length < 4) {
                    console.log(`üîÑ Fallback: Solo ${finalMatches.length} partidos con espectadores, agregando partidos en vivo...`);
                    
                    // Obtener partidos en vivo como fallback (SOLO F√öTBOL)
                    // Excluir partidos que ya est√°n en la lista principal
                    const existingTitlesForFallback = new Set(finalMatches.map(m => m.title.toLowerCase().trim()));
                    
                    const liveMatches = allMatches.filter(match => {
                        // Excluir si ya est√° en la lista principal
                        if (existingTitlesForFallback.has(match.title.toLowerCase().trim())) {
                            return false;
                        }
                        // Filtro estricto de f√∫tbol
                        const title = match.title?.toLowerCase() || '';
                        const category = match.category?.toLowerCase() || '';
                        
                        // Excluir otros deportes
                        const nonFootballKeywords = ['tennis', 'basketball', 'baseball', 'cricket', 'hockey', 'volleyball', 'rugby', 'golf', 'boxing', 'mma', 'ufc', 'wrestling', 'esports', 'e-sports', 'csgo', 'lol', 'dota', 'valorant', 'grandstand', 'christopher', 'alex', 'minaur', 'oconnell', 'player', 'players', 'singles', 'doubles', 'mixed', 'qualifying', 'main draw', 'round', 'final', 'semifinal', 'quarterfinal', 'robin', 'group', 'pool', 'bracket', 'softball', 'caribbean premier league', 'athletes unlimited', 'ncaa men\'s soccer'];
                        
                        if (nonFootballKeywords.some(keyword => title.includes(keyword))) {
                            return false;
                        }
                        
                        // Incluir solo f√∫tbol REAL (m√°s estricto)
                        const footballKeywords = ['football', 'futbol', 'liga', 'champions', 'bundesliga', 'serie a', 'la liga', 'mls', 'copa', 'championship', 'division', 'conference', 'playoff', 'play-off', 'play off'];
                        const isFootballByCategory = category === 'football';
                        const isFootballByKeywords = footballKeywords.some(keyword => 
                            title.includes(keyword) || category.includes(keyword)
                        );
                        
                        // Solo incluir si tiene "vs" Y es f√∫tbol por categor√≠a O keywords
                        const hasVs = (title.includes(' vs ') || title.includes(' versus '));
                        const isFootball = isFootballByCategory || (isFootballByKeywords && hasVs);
                        const isLive = getMatchStatus(match) === 'live';
                        
                        return isFootball && isLive;
                    });
                    
                    // Ordenar partidos en vivo por tiempo (m√°s recientes primero)
                    const sortedLiveMatches = liveMatches.sort((a, b) => {
                        if (!a.time && !b.time) return 0;
                        if (!a.time) return 1;
                        if (!b.time) return -1;
                        
                        const timeA = new Date(a.time);
                        const timeB = new Date(b.time);
                        return timeB - timeA; // Orden descendente (m√°s reciente primero)
                    });
                    
                    // Agregar partidos en vivo que no est√©n ya en la lista
                    const existingIds = new Set(finalMatches.map(m => m.id));
                    const existingTitles = new Set(finalMatches.map(m => m.title.toLowerCase().trim()));
                    
                    const additionalLiveMatches = sortedLiveMatches
                        .filter(match => {
                            // Verificar por ID y por t√≠tulo para evitar duplicados
                            const isDuplicateId = existingIds.has(match.id);
                            const isDuplicateTitle = existingTitles.has(match.title.toLowerCase().trim());
                            return !isDuplicateId && !isDuplicateTitle;
                        })
                        .slice(0, 8 - finalMatches.length);
                    
                    // Combinar partidos con espectadores + partidos en vivo
                    finalMatches = [...finalMatches, ...additionalLiveMatches];
                    
                    console.log(`‚úÖ Fallback completado: ${finalMatches.length} partidos total (${sortedByTime.length} con espectadores + ${additionalLiveMatches.length} en vivo)`);
                    
                    // Verificar duplicados
                    const titles = finalMatches.map(m => m.title);
                    const duplicates = titles.filter((title, index) => titles.indexOf(title) !== index);
                    if (duplicates.length > 0) {
                        console.log('‚ö†Ô∏è Duplicados detectados:', duplicates);
                    } else {
                        console.log('‚úÖ No hay duplicados en la lista final');
                    }
                }
                
                // Eliminar duplicados finales por t√≠tulo
                const uniqueFinalMatches = [];
                const seenTitles = new Set();
                
                for (const match of finalMatches) {
                    const normalizedTitle = match.title.toLowerCase().trim();
                    if (!seenTitles.has(normalizedTitle)) {
                        seenTitles.add(normalizedTitle);
                        uniqueFinalMatches.push(match);
                    }
                }
                
                console.log(`üéØ Lista final sin duplicados: ${uniqueFinalMatches.length} partidos`);
                uniqueFinalMatches.forEach((match, index) => {
                    console.log(`  ${index + 1}. ${match.title}`);
                });
                
                // GARANTIZAR M√çNIMO 5 TARJETAS: Si no hay suficientes, llenar con partidos programados
                if (uniqueFinalMatches.length < 5) {
                    console.log(`üîÑ Solo ${uniqueFinalMatches.length} partidos, llenando con partidos programados...`);
                    
                    // Debug: contar partidos de f√∫tbol totales
                    const totalFootballMatches = allMatches.filter(match => {
                        const title = match.title?.toLowerCase() || '';
                        const category = match.category?.toLowerCase() || '';
                        const footballKeywords = ['football', 'futbol', 'liga', 'champions', 'bundesliga', 'serie a', 'la liga', 'mls', 'copa', 'championship', 'division', 'conference', 'playoff', 'play-off', 'play off'];
                        const isFootballByCategory = category === 'football';
                        const isFootballByKeywords = footballKeywords.some(keyword => 
                            title.includes(keyword) || category.includes(keyword)
                        );
                        const hasVs = (title.includes(' vs ') || title.includes(' versus '));
                        return isFootballByCategory || (isFootballByKeywords && hasVs);
                    });
                    console.log(`üîç Total partidos de f√∫tbol disponibles: ${totalFootballMatches.length}`);
                    
                    // Obtener partidos programados como fallback
                    const scheduledMatches = allMatches.filter(match => {
                        // Excluir si ya est√° en la lista principal
                        if (seenTitles.has(match.title.toLowerCase().trim())) {
                            return false;
                        }
                        
                        // Filtro estricto de f√∫tbol
                        const title = match.title?.toLowerCase() || '';
                        const category = match.category?.toLowerCase() || '';
                        
                        // Excluir otros deportes
                        const nonFootballKeywords = ['tennis', 'basketball', 'baseball', 'cricket', 'hockey', 'volleyball', 'rugby', 'golf', 'boxing', 'mma', 'ufc', 'wrestling', 'esports', 'e-sports', 'csgo', 'lol', 'dota', 'valorant', 'grandstand', 'christopher', 'alex', 'minaur', 'oconnell', 'player', 'players', 'singles', 'doubles', 'mixed', 'qualifying', 'main draw', 'round', 'final', 'semifinal', 'quarterfinal', 'robin', 'group', 'pool', 'bracket', 'softball', 'caribbean premier league', 'athletes unlimited', 'ncaa men\'s soccer'];
                        
                        if (nonFootballKeywords.some(keyword => title.includes(keyword))) {
                            return false;
                        }
                        
                        // Solo f√∫tbol programado
                        const footballKeywords = ['football', 'futbol', 'liga', 'champions', 'bundesliga', 'serie a', 'la liga', 'mls', 'copa', 'championship', 'division', 'conference', 'playoff', 'play-off', 'play off'];
                        const isFootballByCategory = category === 'football';
                        const isFootballByKeywords = footballKeywords.some(keyword => 
                            title.includes(keyword) || category.includes(keyword)
                        );
                        const hasVs = (title.includes(' vs ') || title.includes(' versus '));
                        const isFootball = isFootballByCategory || (isFootballByKeywords && hasVs);
                        
                        // Debug: ver qu√© partidos est√°n siendo evaluados
                        if (isFootball) {
                            const status = getMatchStatus(match);
                            console.log(`üîç Evaluando en vivo/programado: ${match.title} - Status: ${status} - Time: ${match.time}`);
                        }
                        
                        // Usar exactamente la misma l√≥gica que el filtro de programados
                        const isLive = getMatchStatus(match) === 'live';
                        const isScheduled = getMatchStatus(match) === 'scheduled';
                        
                        return isFootball && (isLive || isScheduled);
                    });
                    
                    console.log(`üîç Partidos en vivo/programados encontrados: ${scheduledMatches.length}`);
                    if (scheduledMatches.length > 0) {
                        console.log('üìã Partidos en vivo/programados:', scheduledMatches.map(m => m.title));
                    }
                    
                    // Ordenar partidos programados por tiempo (m√°s temprano primero)
                    const sortedScheduledMatches = scheduledMatches.sort((a, b) => {
                        if (!a.time && !b.time) return 0;
                        if (!a.time) return 1;
                        if (!b.time) return -1;
                        
                        const timeA = new Date(a.time);
                        const timeB = new Date(b.time);
                        return timeA - timeB;
                    });
                    
                    // Agregar partidos programados hasta completar m√≠nimo 5
                    const neededMatches = 5 - uniqueFinalMatches.length;
                    const additionalScheduledMatches = sortedScheduledMatches.slice(0, neededMatches);
                    
                    // Combinar partidos principales + partidos programados
                    const finalWithScheduled = [...uniqueFinalMatches, ...additionalScheduledMatches];
                    
                    console.log(`‚úÖ Llenado completado: ${finalWithScheduled.length} partidos total (${uniqueFinalMatches.length} principales + ${additionalScheduledMatches.length} programados)`);
                    
                    return finalWithScheduled.slice(0, 8);
                }
                
                return uniqueFinalMatches.slice(0, 8);
                
            } catch (error) {
                console.error('Error loading streams with most viewers:', error);
                return [];
            }
        }

        async function updateTrendingSection(showFallback = true) {
            const trendingContainer = document.getElementById('row-trending-top');
            if (!trendingContainer) return;
            
            // FALLBACK INMEDIATO: Solo mostrar en la carga inicial
            if (showFallback) {
                const rowTrack = trendingContainer.querySelector('.row-track');
                if (!rowTrack) return;
                
                // Mostrar fallback inmediato con partidos en vivo Y programados
                const fallbackMatches = allMatches.filter(match => {
                    const title = match.title?.toLowerCase() || '';
                    const category = match.category?.toLowerCase() || '';
                    
                    // Excluir otros deportes
                    const nonFootballKeywords = ['tennis', 'basketball', 'baseball', 'cricket', 'hockey', 'volleyball', 'rugby', 'golf', 'boxing', 'mma', 'ufc', 'wrestling', 'esports', 'e-sports', 'csgo', 'lol', 'dota', 'valorant', 'softball', 'caribbean premier league', 'athletes unlimited', 'ncaa men\'s soccer'];
                    
                    if (nonFootballKeywords.some(keyword => title.includes(keyword))) {
                        return false;
                    }
                    
                    // Usar exactamente la misma l√≥gica que el filtro de programados
                    const footballKeywords = ['football', 'futbol', 'liga', 'champions', 'bundesliga', 'serie a', 'la liga', 'mls', 'copa', 'championship', 'division', 'conference', 'playoff', 'play-off', 'play off'];
                    const isFootballByCategory = category === 'football';
                    const isFootballByKeywords = footballKeywords.some(keyword => 
                        title.includes(keyword) || category.includes(keyword)
                    );
                    const hasVs = (title.includes(' vs ') || title.includes(' versus '));
                    const isFootball = isFootballByCategory || (isFootballByKeywords && hasVs);
                    const isLive = getMatchStatus(match) === 'live';
                    const isScheduled = getMatchStatus(match) === 'scheduled';
                    
                    return isFootball && (isLive || isScheduled);
                }).slice(0, 8);
                
                // Mostrar fallback inmediato
                if (fallbackMatches.length > 0) {
                    console.log('üîÑ Mostrando fallback inmediato con', fallbackMatches.length, 'partidos (en vivo + programados)');
                    displayTrendingMatches(fallbackMatches);
                }
            }
            
            // Cargar streams con m√°s espectadores desde la API de Streamed
            const topViewersMatches = await loadStreamsWithMostViewers();
            
            if (topViewersMatches.length === 0) {
                console.log('‚ùå No se encontraron partidos de f√∫tbol con espectadores ni en vivo');
                return;
            }
            
            console.log('‚öΩ Actualizando secci√≥n de tendencias con', topViewersMatches.length, 'partidos de f√∫tbol con m√°s espectadores');
            
            // Ordenar por n√∫mero de espectadores (descendente) - ya vienen ordenados de la API
            const ordered = topViewersMatches;
            
            if (ordered.length === 0) return;
            
            // Actualizar con los partidos con espectadores
            displayTrendingMatches(ordered);
        }
        
        function displayTrendingMatches(matches) {
            const trendingContainer = document.getElementById('row-trending-top');
            if (!trendingContainer) return;
            
            const rowTrack = trendingContainer.querySelector('.row-track');
            if (!rowTrack) return;
            
            rowTrack.innerHTML = '';
            
            console.log('üé® Creando', matches.length, 'tarjetas de tendencias...');
            console.log('üìã Partidos a mostrar:', matches.map(m => ({ id: m.id, title: m.title, hasSources: !!m.sources })));
            
            matches.forEach(match => {
                const status = getMatchStatus(match);
                
                // Debug: mostrar estado del partido
                const timeStr = match.time ? new Date(match.time).toLocaleString() : 'Sin tiempo';
                console.log(`üîç ${match.title}: ${timeStr} -> Estado: ${status}`);
                
                // Extraer equipos del t√≠tulo (robusto)
                let homeTeam = 'Equipo Local';
                let awayTeam = 'Equipo Visitante';
                const parsed = extractTeamsFromTitle(match.title || '');
                if (parsed) {
                    homeTeam = parsed[0];
                    awayTeam = parsed[1];
                }

                // Limpiar y normalizar a espa√±ol (solo equipos)
                homeTeam = normalizeTeamSpanish(limpiarNombreEquipo(homeTeam));
                awayTeam = normalizeTeamSpanish(limpiarNombreEquipo(awayTeam));
                
                // Categor√≠a a mostrar con sistema de normalizaci√≥n (sin gen√©rico)
                const displayCategory = getDisplayCategory(match);
                console.log('üéØ displayCategory para', match.title, ':', displayCategory);
                
                // Obtener URL de la imagen del partido - PRIORIZAR BADGES DE EQUIPOS
                let posterUrl = null;
                
                // Si NO tiene espectadores, priorizar badges de equipos
                if (!match.topViewers || match.topViewers === 0) {
                    // 1. Intentar construir poster compuesto: /api/images/poster/{home}/{away}.webp
                    if (match?.teams?.home?.badge && match?.teams?.away?.badge) {
                        const home = match.teams.home.badge;
                        const away = match.teams.away.badge;
                        posterUrl = `https://streamed.pk/api/images/poster/${home}/${away}.webp`;
                        console.log('üñºÔ∏è Usando poster compuesto (sin espectadores):', posterUrl);
                    }
                    // 2. Si no hay poster compuesto, intentar usar el badge del equipo local
                    else if (match?.teams?.home?.badge) {
                        posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.home.badge}.webp`;
                        console.log('üñºÔ∏è Usando badge equipo local (sin espectadores):', posterUrl);
                    }
                    // 3. Si no hay badge del equipo local, intentar con el equipo visitante
                    else if (match?.teams?.away?.badge) {
                        posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.away.badge}.webp`;
                        console.log('üñºÔ∏è Usando badge equipo visitante (sin espectadores):', posterUrl);
                    }
                    // 4. Si no hay estructura teams, intentar generar un badge basado en el t√≠tulo
                    else if (match.title) {
                        const titleHash = btoa(match.title).replace(/[^a-zA-Z0-9]/g, '').substring(0, 20);
                        posterUrl = `https://streamed.pk/api/images/proxy/${titleHash}.webp`;
                        console.log('üñºÔ∏è Usando badge generado del t√≠tulo (sin espectadores):', posterUrl);
                    }
                }
                
                // Si S√ç tiene espectadores o no se encontr√≥ badge, usar poster de Streamed
                if (!posterUrl) {
                    // 1. Intentar usar el poster del partido si existe
                    if (match.poster) {
                        if (match.poster.startsWith('http')) {
                            posterUrl = match.poster;
                            console.log('üñºÔ∏è Usando poster externo:', posterUrl);
                        } else {
                            if (match.poster.startsWith('/api/images/poster/')) {
                                posterUrl = `https://streamed.pk${match.poster}`;
                            } else if (match.poster.startsWith('api/images/poster/')) {
                                posterUrl = `https://streamed.pk/${match.poster}`;
                            } else if (match.poster.startsWith('/api/images/proxy/')) {
                                posterUrl = `https://streamed.pk${match.poster}`;
                            } else if (match.poster.startsWith('api/images/proxy/')) {
                                posterUrl = `https://streamed.pk/${match.poster}`;
                            } else {
                                posterUrl = `https://streamed.pk/api/images/proxy/${match.poster}`;
                            }
                            console.log('üñºÔ∏è Usando poster de Streamed:', posterUrl);
                        }
                    }
                    // 2. Si no hay poster, intentar badges de equipos como fallback
                    else if (match?.teams?.home?.badge && match?.teams?.away?.badge) {
                        const home = match.teams.home.badge;
                        const away = match.teams.away.badge;
                        posterUrl = `https://streamed.pk/api/images/poster/${home}/${away}.webp`;
                        console.log('üñºÔ∏è Usando poster compuesto (fallback):', posterUrl);
                    }
                    else if (match?.teams?.home?.badge) {
                        posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.home.badge}.webp`;
                        console.log('üñºÔ∏è Usando badge equipo local (fallback):', posterUrl);
                    }
                    else if (match?.teams?.away?.badge) {
                        posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.away.badge}.webp`;
                        console.log('üñºÔ∏è Usando badge equipo visitante (fallback):', posterUrl);
                    }
                    else if (match.title) {
                        const titleHash = btoa(match.title).replace(/[^a-zA-Z0-9]/g, '').substring(0, 20);
                        posterUrl = `https://streamed.pk/api/images/proxy/${titleHash}.webp`;
                        console.log('üñºÔ∏è Usando badge generado del t√≠tulo (fallback):', posterUrl);
                    }
                }
                
                if (!posterUrl) {
                    console.log('‚ùå No se encontr√≥ imagen para:', match.title, 'Teams:', match.teams);
                }
                
                // Wrapper para tarjeta + leyenda inferior
                const wrapper = document.createElement('div');
                wrapper.style.display = 'flex';
                wrapper.style.flexDirection = 'column';
                wrapper.style.width = '216px';
                wrapper.style.gap = '6px';
                wrapper.style.overflow = 'hidden';
                wrapper.style.flexShrink = '0';
                
                const tile = document.createElement('button');
                tile.className = 'tile';
                tile.setAttribute('role', 'listitem');
                tile.setAttribute('tabindex', '14');
                tile.onclick = () => openBestStream(match.id, match.title);
                
                // Renderizar con imagen espec√≠fica con mejor manejo de errores
                if (posterUrl) {
                    tile.innerHTML = `
                        <img src="${posterUrl}" alt="${match.title || 'Partido'}" 
                             onerror="this.onerror=null; this.src='https://koogle.com/images/fallback.webp';" 
                             onload="this.nextElementSibling.style.display='none';" />
                        <div style="background: #2d2d2d; width: 100%; height: 100%; display: none; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 2rem;">‚öΩ</div>
                        <div class="viewer-count" style="position: absolute; top: 8px; right: 8px; background: #ff6b35; color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: bold; z-index: 10;">üëÅÔ∏è ${match.topViewers || 0}</div>
                    `;
                } else {
                    // Sin imagen disponible: fondo con √≠cono de f√∫tbol
                    tile.innerHTML = `
                        <div style="background: #2d2d2d; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 2rem;">‚öΩ</div>
                        <div class="viewer-count" style="position: absolute; top: 8px; right: 8px; background: #ff6b35; color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: bold; z-index: 10;">üëÅÔ∏è ${match.topViewers || 0}</div>
                    `;
                }
                
                // NO agregar informaci√≥n superpuesta sobre la imagen
                
                // Leyenda debajo de la tarjeta (sin texto dentro de la tarjeta)
                const caption = document.createElement('div');
                caption.style.display = 'flex';
                caption.style.flexDirection = 'column';
                caption.style.gap = '2px';
                
                const titleLine = document.createElement('span');
                titleLine.style.color = '#ffffff';
                titleLine.style.fontSize = '0.9rem';
                titleLine.style.fontWeight = '700';
                titleLine.style.overflow = 'hidden';
                titleLine.style.textOverflow = 'ellipsis';
                titleLine.style.whiteSpace = 'nowrap';
                titleLine.style.maxWidth = '216px';
                titleLine.textContent = `${homeTeam} vs ${awayTeam}`;
                
                const sportLine = document.createElement('span');
                sportLine.style.color = '#b3b3b3';
                sportLine.style.fontSize = '0.7rem';
                sportLine.style.fontWeight = '500';
                sportLine.style.overflow = 'hidden';
                sportLine.style.textOverflow = 'ellipsis';
                sportLine.style.whiteSpace = 'nowrap';
                sportLine.style.maxWidth = '216px';
                sportLine.textContent = `${displayCategory} ‚Ä¢ ${match.topViewers || 0} espectadores`;
                if (!displayCategory) sportLine.style.display = 'none';
                
                caption.appendChild(titleLine);
                caption.appendChild(sportLine);
                
                wrapper.appendChild(tile);
                wrapper.appendChild(caption);
                
                rowTrack.appendChild(wrapper);
            });
            
            console.log('‚úÖ Tarjetas de tendencias creadas y agregadas al DOM');
        }

        // Funci√≥n para encontrar el elemento focusable m√°s cercano
        function findNearestFocusableElement(currentElement, direction) {
            const focusableElements = Array.from(document.querySelectorAll(
                'button, [tabindex]:not([tabindex="-1"]), a[href], input, select, textarea, [contenteditable="true"]'
            )).filter(el => {
                const rect = el.getBoundingClientRect();
                return rect.width > 0 && rect.height > 0 && !el.disabled && el.style.display !== 'none';
            });

            if (focusableElements.length === 0) return null;

            const currentRect = currentElement.getBoundingClientRect();
            const currentCenter = {
                x: currentRect.left + currentRect.width / 2,
                y: currentRect.top + currentRect.height / 2
            };

            let nearestElement = null;
            let minDistance = Infinity;

            focusableElements.forEach(element => {
                if (element === currentElement) return;

                const rect = element.getBoundingClientRect();
                const center = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };

                let distance = Infinity;
                let isValidDirection = false;

                switch (direction) {
                    case 'up':
                        if (center.y < currentCenter.y) {
                            distance = Math.sqrt(Math.pow(center.x - currentCenter.x, 2) + Math.pow(center.y - currentCenter.y, 2));
                            isValidDirection = true;
                        }
                        break;
                    case 'down':
                        if (center.y > currentCenter.y) {
                            distance = Math.sqrt(Math.pow(center.x - currentCenter.x, 2) + Math.pow(center.y - currentCenter.y, 2));
                            isValidDirection = true;
                        }
                        break;
                    case 'left':
                        if (center.x < currentCenter.x) {
                            distance = Math.sqrt(Math.pow(center.x - currentCenter.x, 2) + Math.pow(center.y - currentCenter.y, 2));
                            isValidDirection = true;
                        }
                        break;
                    case 'right':
                        if (center.x > currentCenter.x) {
                            distance = Math.sqrt(Math.pow(center.x - currentCenter.x, 2) + Math.pow(center.y - currentCenter.y, 2));
                            isValidDirection = true;
                        }
                        break;
                }

                if (isValidDirection && distance < minDistance) {
                    minDistance = distance;
                    nearestElement = element;
                }
            });

            // Si no hay elemento en la direcci√≥n especificada, buscar el m√°s cercano en cualquier direcci√≥n
            if (!nearestElement) {
                focusableElements.forEach(element => {
                    if (element === currentElement) return;

                    const rect = element.getBoundingClientRect();
                    const center = {
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2
                    };

                    const distance = Math.sqrt(Math.pow(center.x - currentCenter.x, 2) + Math.pow(center.y - currentCenter.y, 2));
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestElement = element;
                    }
                });
            }

            return nearestElement;
        }

        // Event listeners
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeStreamOverlay();
                closeModal();
            }
            
            // Prevenir que el foco del bot√≥n VER AHORA afecte el layout del carrusel
            if (e.key === 'Tab' || e.key === 'Enter') {
                const focusedElement = document.activeElement;
                if (focusedElement && focusedElement.classList.contains('btn-watch')) {
                    // Asegurar que el carrusel mantenga su posici√≥n
                    const carruselTrack = document.getElementById('carruselTrack');
                    if (carruselTrack) {
                        const currentTransform = carruselTrack.style.transform;
                        setTimeout(() => {
                            carruselTrack.style.transform = currentTransform;
                        }, 0);
                    }
                }
            }
            
            // Navegaci√≥n circular con control remoto Android TV
            const focusedElement = document.activeElement;
            
            // Si el foco est√° en el bot√≥n del carrusel, permitir navegaci√≥n del carrusel
            if (focusedElement && (focusedElement.id === 'carruselNext' || focusedElement.id === 'carruselPrev')) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    moverCarrusel(-1);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    moverCarrusel(1);
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    const direction = e.key === 'ArrowUp' ? 'up' : 'down';
                    const nearestElement = findNearestFocusableElement(focusedElement, direction);
                    if (nearestElement) nearestElement.focus();
                }
            } else if (focusedElement && focusedElement.classList.contains('tile')) {
                // Navegaci√≥n para tarjetas de tendencias
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    const direction = e.key === 'ArrowLeft' ? 'left' : 'right';
                    const nearestElement = findNearestFocusableElement(focusedElement, direction);
                    if (nearestElement) nearestElement.focus();
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    const direction = e.key === 'ArrowUp' ? 'up' : 'down';
                    const nearestElement = findNearestFocusableElement(focusedElement, direction);
                    if (nearestElement) nearestElement.focus();
                }
            } else if (focusedElement) {
                // Navegaci√≥n general para cualquier elemento focusable
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    const direction = e.key.replace('Arrow', '').toLowerCase();
                    const nearestElement = findNearestFocusableElement(focusedElement, direction);
                    if (nearestElement) {
                        nearestElement.focus();
                        console.log('üéØ Navegaci√≥n circular:', direction, '->', nearestElement.textContent || nearestElement.className);
                    }
                }
            }
        });

        // Funci√≥n para establecer foco inicial
        function setInitialFocus() {
            // Establecer foco en el primer bot√≥n de filtros
            const firstFilterBtn = document.querySelector('.vertical-filter-btn[tabindex="1"]');
            if (firstFilterBtn) {
                firstFilterBtn.focus();
                console.log('üéØ Foco inicial establecido en filtros');
            }
        }





        // Initialize
        window.addEventListener('load', async () => {
            console.log('üöÄ Streamed Replica iniciado');
            
            // üéØ ESTABLECER FOCO INICIAL PRIMERO (antes que todo)
            setInitialFocus();
            
            // Cargar equipos de MLS primero
            await loadMLSTeams();
            
            // Luego cargar partidos
            await loadMatches('football'); // Load football matches by default
            
            // No aplicar filtro por defecto - mostrar todos los partidos (m√°s r√°pido)
            
            // Cargar tendencias (partidos populares) independientemente
            updateTrendingSection();
            
            // Actualizaci√≥n autom√°tica de tendencias cada 10 segundos
            setInterval(() => {
                console.log('üîÑ Actualizando tendencias autom√°ticamente...');
                updateTrendingSection(false); // No mostrar fallback en actualizaciones autom√°ticas
            }, 10000); // 10 segundos
            
            // Funci√≥n para actualizar solo los contadores de espectadores de forma suave
            function updateViewerCounts() {
                const trendingContainer = document.getElementById('row-trending-top');
                if (!trendingContainer) return;
                
                const viewerCounts = trendingContainer.querySelectorAll('[data-match-id]');
                viewerCounts.forEach(async (element) => {
                    const matchId = element.getAttribute('data-match-id');
                    const viewerElement = element.querySelector('.viewer-count');
                    if (viewerElement) {
                        // Efecto de fade out
                        viewerElement.style.opacity = '0.5';
                        viewerElement.style.transform = 'scale(0.95)';
                        
                        // Simular actualizaci√≥n (aqu√≠ podr√≠as hacer una llamada real a la API)
                        setTimeout(() => {
                            viewerElement.style.opacity = '1';
                            viewerElement.style.transform = 'scale(1)';
                        }, 150);
                    }
                });
            }
            
            // Desactivado: no reemplazar por Champions autom√°ticamente
            // Si se requiere, usar el filtro manual desde el UI
         });

        function logCategoryDiagnostics(matches) {
            try {
                const distinct = new Set();
                const samples = [];
                matches.slice(0, 20).forEach(m => {
                    const cat = getCategory(m);
                    if (cat) distinct.add(cat);
                    samples.push({
                        title: m.title,
                        categoryDetected: cat,
                        raw: {
                            competition: m.competition,
                            tournament: m.tournament,
                            event: m.event,
                            category: m.category,
                            league: m.league,
                            sport: m.sport
                        }
                    });
                });
                console.log('üß≠ Categor√≠as detectadas (√∫nicas):', Array.from(distinct));
                console.log('üß™ Muestras de categor√≠a por partido:', samples);
            } catch (e) {
                console.log('Diag error:', e.message);
            }
        }

        function isTodayLocal(dateMs) {
            if (!dateMs || typeof dateMs !== 'number' || dateMs <= 0) return false;
            const d = new Date(dateMs);
            const now = new Date();
            return d.getFullYear() === now.getFullYear() && d.getMonth() === now.getMonth() && d.getDate() === now.getDate();
        }
    </script>
</body>
</html>
