<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Football Streaming - Live Football on TV for FREE - Streamed</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #1a1a1a;
            --secondary-color: #2d2d2d;
            --accent-color: #ff6b35;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --text-muted: #808080;
            --border-color: #404040;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --live-color: #dc2626;
            --scheduled-color: #059669;
            --finished-color: #6b7280;
        }

        html {
            width: 1280px;
            height: 720px;
            overflow: hidden;
        }

        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: var(--primary-color);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
            width: 1280px;
            height: 720px;
            margin: 0 auto;
            position: relative;
        }





        /* Main Content */
        .main-content {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0.5rem;
            overflow: hidden;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        /* Filters */
        .filters {
            background: var(--secondary-color);
            border-radius: 8px;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .filters-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .filters-title {
            font-size: 1rem;
            font-weight: 700;
        }

        .filter-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 0.25rem 0.5rem;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.75rem;
        }

        .filter-btn:hover,
        .filter-btn.active {
            background: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        /* Filtros Verticales */
        .vertical-filters {
            position: fixed;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            background: transparent;
            padding: 2rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .filter-group-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0;
            text-align: center;
        }

        .vertical-filter-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .vertical-filter-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .vertical-filter-btn:focus {
            background: var(--accent-color);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.5);
        }

        .vertical-filter-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 60px;
            font-size: 0.75rem;
        }

        .vertical-filter-btn:hover {
            background: rgba(255, 107, 53, 0.1);
            color: var(--accent-color);
            transform: translateX(5px);
        }

        .vertical-filter-btn.active {
            background: rgba(255, 107, 53, 0.2);
            color: var(--accent-color);
            box-shadow: none;
        }

        .filter-icon {
            font-size: 1.2rem;
            line-height: 1;
        }

        .filter-text {
            font-size: 0.6rem;
            font-weight: 500;
            text-align: center;
            line-height: 1;
        }



        /* Matches Grid */
        /* Carrusel Styles */
        .carrusel-container {
            position: relative;
            width: 100%;
            flex: 1;
            overflow: hidden;
            background: transparent;
        }

        .carrusel-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            background: transparent;
        }

        .carrusel-track {
            display: flex;
            transition: transform 0.5s ease-in-out;
            height: 100%;
            flex: 1;
            background: transparent;
        }

        .carrusel-track .match-card {
            flex: 0 0 100%;
            width: 100%;
            height: 100%;
            margin: 0;
            border-radius: 0;
        }

        .carrusel-container .carrusel-btn {
            position: absolute;
            top: 20%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .carrusel-container .carrusel-btn:hover {
            background: rgba(255, 107, 53, 0.9);
            transform: translateY(-50%) scale(1.1);
        }

        .carrusel-container .carrusel-btn:focus {
            background: rgba(255, 107, 53, 0.9);
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.6);
            outline: 3px solid var(--accent-color);
        }

        /* Estilos para el botón del carrusel que está fuera del contenedor */
        .carrusel-btn:not(.carrusel-container .carrusel-btn) {
            position: static;
            transform: translateX(90%);
            background: rgba(255, 107, 53, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 12px;
            cursor: pointer;
            padding: 0;
            margin: 5px 0;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .carrusel-btn:not(.carrusel-container .carrusel-btn):hover {
            background: rgba(255, 107, 53, 1);
            transform: translateX(90%) scale(1.1);
        }

        .carrusel-btn:not(.carrusel-container .carrusel-btn):focus {
            background: rgba(255, 107, 53, 1);
            transform: translateX(90%) scale(1.1);
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
            outline: 2px solid var(--accent-color);
            outline-offset: 1px;
        }

        .carrusel-container .carrusel-prev {
            left: -60px;
        }

        .carrusel-container .carrusel-next {
            right: 20px;
        }

        .indicadores-pagina {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .indicador {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .indicador.activo {
            background: #ff6b35;
            transform: scale(1.2);
        }

        .match-card {
            background: transparent;
            border-radius: 0;
            overflow: hidden;
            border: none;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .match-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .match-poster {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            opacity: 0.3;
            transition: all 0.3s ease;
        }

        .match-card:hover .match-poster {
            opacity: 0.4;
            transform: scale(1.05);
        }

        .match-card.no-poster {
            background: transparent;
        }

        .match-card.no-poster .match-overlay {
            background: transparent;
        }

        .match-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: transparent;
            display: flex;
            flex-direction: column;
        }

        .match-header {
            padding: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .match-time {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .match-status {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .status-live {
            background: #e55a2b !important;
            color: #ffffff !important;
            width: auto !important;
            height: 24px !important;
            padding: 2px 12px 0 12px !important;
            border-radius: 12px !important;
            text-decoration: none !important;
            font-size: 12px !important;
            font-weight: 600 !important;
            transition: all 0.3s ease !important;
            border: 2px solid transparent !important;
            cursor: pointer !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            outline: none !important;
            position: relative !important;
            overflow: hidden !important;
            text-shadow: none !important;
        }



        .status-live:hover {
            transform: scale(1.05);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .status-scheduled {
            background: var(--scheduled-color);
            color: white;
        }

        .status-finished {
            background: var(--finished-color);
            color: white;
        }

        .contenido-texto {
            position: absolute;
            top: 0%;
            left: 9%;
            transform: scale(0.98);
            transform-origin: left top;
            max-width: 70%;
            z-index: 10 !important;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            /* Prevenir que el foco de elementos hijos afecte la posición */
            pointer-events: auto;
        }



        .branding {
            font-size: 0.8rem;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .contenido-texto h2 {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            line-height: 1.2;
        }

        .metadata {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            font-size: 1rem;
            color: #b3b3b3;
        }

        .bullet {
            color: #ff6b35;
            font-weight: bold;
        }

        .contenido-texto p {
            font-size: 1.1rem;
            line-height: 1.5;
            margin-bottom: 1.5rem;
            color: #e0e0e0;
            max-width: 70%;
            text-align: left;
        }

        .botones-container {
            display: flex;
            gap: 10px;
            max-width: 100%;
            width: 100%;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: flex-start;
        }

        .botones-container a,
        .botones-container button {
            width: 236px;
            height: 42px;
            padding: 0;
            border: none;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.7rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--accent-color);
            color: white;
            text-decoration: none;
        }

        .botones-container a:hover,
        .botones-container button:hover {
            background: rgba(255, 107, 53, 1);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }



        @keyframes pulse-live {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(220, 38, 38, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(220, 38, 38, 0.6);
            }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .status-scheduled {
            background: linear-gradient(135deg, #059669, #10b981);
            color: white;
            font-weight: 700;
            width: auto !important;
            height: 24px !important;
            padding: 2px 12px 0 12px !important;
            border-radius: 12px !important;
            font-size: 12px !important;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(5, 150, 105, 0.4);
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            text-shadow: none !important;
        }

        .status-finished {
            background: linear-gradient(135deg, #6b7280, #9ca3af);
            color: white;
            font-weight: 700;
            width: auto !important;
            height: 24px !important;
            padding: 2px 12px 0 12px !important;
            border-radius: 12px !important;
            font-size: 12px !important;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(107, 114, 128, 0.4);
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            text-shadow: none !important;
        }

        /* Estilos eliminados - ahora usando .contenido-texto */

        .action-btn {
            cursor: pointer;
        }

        /* Estilos para botones de aplicaciones */
        .app-icon {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: none;
            color: white;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            margin: 0 2px;
            outline: none;
            background-size: cover;
            background-position: center;
        }

        .app-icon:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .app-icon:focus {
            outline: 3px solid #ff6b35;
            outline-offset: 3px;
            transform: scale(1.05);
        }

        .row-track.apps {
            display: flex;
            gap: 10px;
            padding: 0 20px;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            transform: translateY(150%);
        }

        .row-track.apps::-webkit-scrollbar {
            display: none;
        }

        #row-apps {
            transform: translate(0%, -40%);
        }

        #row-apps h3 {
            transform: translateY(130%);
            font-size: 0.8rem;
        }

        .btn-watch {
            background: #000000 !important;
            color: #ffffff !important;
            width: 220px !important;
            height: 50px !important;
            padding: 0 !important;
            border-radius: 28px !important;
            text-decoration: none !important;
            font-size: 18px !important;
            font-weight: 600 !important;
            transition: all 0.3s ease !important;
            border: 4px solid #ff6b35 !important;
            cursor: pointer !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            outline: none !important;
            position: relative !important;
            overflow: hidden !important;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.3) !important;
            -webkit-appearance: none !important;
            -webkit-tap-highlight-color: transparent !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            margin: 2px !important;
            min-width: 220px !important;
            min-height: 50px !important;
            max-width: none !important;
            max-height: none !important;
            tabindex: 0 !important;
        }

        /* Eliminar pseudo-elemento para que solo quede el borde sólido */
        .btn-watch::before {
            display: none !important;
        }

        .btn-watch:hover {
            transform: scale(1.05);
        }

        .btn-watch:focus {
            outline: 3px solid #ff6b35 !important;
            outline-offset: 5px !important;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.8) !important;
            transform: scale(1.05) !important;
            border-color: #ffffff !important;
            background: #ff6b35 !important;
            color: #000000 !important;
            transition: all 0.2s ease !important;
        }

        /* Optimizaciones específicas para Android */
        @media screen and (max-width: 1920px) {
            .btn-watch {
                font-size: 16px !important;
                width: 180px !important;
                height: 52px !important;
            }
        }

        /* Para Android TV específicamente */
        @media screen and (max-width: 1280px) {
            .btn-watch {
                font-size: 14px !important;
                width: 160px !important;
                height: 48px !important;
                border-width: 3px !important;
            }
        }

        /* Asegurar que el texto sea visible en todos los dispositivos */
        .btn-watch span,
        .btn-watch {
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8) !important;
            font-family: 'Arial', sans-serif !important;
            letter-spacing: 0.5px !important;
            font-size: 18px !important;
        }

        /* Optimización específica para Android TV */
        .btn-watch {
            -webkit-transform: translateZ(0) !important;
            transform: translateZ(0) !important;
            backface-visibility: hidden !important;
            -webkit-backface-visibility: hidden !important;
        }



        /* Asegurar que el texto esté siempre visible */
        .btn-watch span {
            position: relative !important;
            z-index: 10 !important;
            color: #ffffff !important;
            font-weight: bold !important;
            font-size: 18px !important;
        }

        /* Asegurar que el botón sea focusable */
        .btn-watch {
            focusable: true !important;
            -webkit-focusable: true !important;
        }

        /* Animación de pulso para el foco */
        @keyframes focusPulse {
            0% {
                box-shadow: 0 0 20px rgba(255, 107, 53, 0.8);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 107, 53, 1);
            }
            100% {
                box-shadow: 0 0 20px rgba(255, 107, 53, 0.8);
            }
        }

        .btn-watch:focus {
            animation: focusPulse 1.5s ease-in-out infinite !important;
        }





        .btn-details {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .btn-details:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--accent-color);
            color: var(--accent-color);
            transform: translateY(-2px);
        }



        /* Trending Now Row */
        .row {
            position: absolute;
            bottom: 17.82%;
            left: 7%;
            z-index: 50;
            margin: 0;
        }

        #row-trending-top {
            position: absolute !important;
            bottom: 21.256% !important;
            left: 8.5% !important;
            z-index: 50 !important;
            margin: 0 !important;
            width: 90% !important;
            overflow: hidden !important;
            transform: scale(0.982);
            transform-origin: left bottom;
        }

        #row-trending-top h3 {
            transform: translateY(75%) !important;
            margin-top: 0 !important;
            padding-top: 0 !important;
            font-size: 1.2rem;
        }

        .row-track {
            display: flex;
            gap: 1rem;
            overflow-x: scroll !important;
            overflow-y: hidden !important;
            padding: 0.5rem 0;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
            white-space: nowrap !important;
            width: 100% !important;
            min-width: max-content !important;
            scroll-behavior: smooth !important;
        }

        .row h3 {
            color: var(--text-primary);
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            padding-top: 5%;
            text-transform: uppercase;
            letter-spacing: 1px;
        }



        .row-track::-webkit-scrollbar {
            display: none;
        }

        .row-track::-webkit-scrollbar-track {
            display: none;
        }

        .row-track::-webkit-scrollbar-thumb {
            display: none;
        }

        .row-track::-webkit-scrollbar-thumb:hover {
            display: none;
        }
        
        /* Transiciones suaves para actualizaciones */
        .viewer-count {
            transition: all 0.3s ease-in-out;
        }
        
        .tile {
            transition: opacity 0.3s ease-in-out;
        }
        
        .tile img {
            transition: opacity 0.3s ease-in-out;
        }
        
        /* Asegurar que no haya líneas o bordes visibles */
        .tile * {
            border: none !important;
            outline: none !important;
        }
        
        .tile::before,
        .tile::after {
            display: none !important;
        }

        .tile {
            background: var(--secondary-color);
            border: none;
            border-radius: 8px;
            padding: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 216px;
            height: 126px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: none;
        }

        .tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .tile-overlay {
            display: none;
        }

        .tile-subtitle {
            display: block;
            font-size: 0.8rem;
            color: #ccc;
            margin-bottom: 0.25rem;
        }

        .tile-title {
            display: block;
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .platform-logo {
            display: block;
            font-size: 0.7rem;
            color: #999;
            text-transform: uppercase;
            font-weight: 500;
        }

        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .tile:focus {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(255, 107, 53, 0.7);
            outline: 3px solid var(--accent-color);
            outline-offset: 2px;
        }

        /* Streams Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        /* Universal Stream Overlay */
        .stream-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 1280px;
            height: 720px;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            backdrop-filter: blur(10px);
            margin: 0 auto;
        }

        .stream-overlay-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .stream-overlay-header {
            display: none;
        }

        .stream-overlay-title {
            display: none;
        }

        .stream-overlay-close {
            display: none;
        }

        .stream-overlay-body {
            flex: 1;
            padding: 0;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            border: none;
            outline: none;
        }

        .stream-overlay-body iframe {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            background: #000;
            border-radius: 0;
            margin: 0;
            padding: 0;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--secondary-color);
            border-radius: 12px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid var(--border-color);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 700;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: var(--primary-color);
            color: var(--text-primary);
        }

        .streams-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .stream-item {
            background: var(--primary-color);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stream-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .stream-quality {
            background: var(--success-color);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .stream-source {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .stream-actions {
            display: flex;
            gap: 0.5rem;
        }

        .stream-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.875rem;
        }

        .btn-embed {
            background: var(--accent-color);
            color: white;
        }

        .btn-embed:hover {
            background: #e55a2b;
        }

        .btn-copy {
            background: var(--success-color);
            color: white;
        }

        .btn-copy:hover {
            background: #059669;
        }

        /* Loading */
        .loading {
            display: none;
            text-align: center;
            padding: 3rem;
        }

        .spinner {
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error/Empty States */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }

        .empty-icon {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            opacity: 0.6;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }

        .empty-state h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .empty-state p {
            font-size: 1rem;
            color: var(--text-secondary);
            margin: 0;
        }

        /* Footer */
        .footer {
            background: var(--secondary-color);
            border-top: 1px solid var(--border-color);
            padding: 2rem;
            margin-top: 4rem;
            text-align: center;
        }

        .footer-content {
            max-width: 1300px;
            margin: 0 auto;
        }

        .footer p {
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            flex-wrap: wrap;
        }

        .footer-link {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .footer-link:hover {
            color: var(--accent-color);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header-content {
                padding: 1rem;
                flex-direction: column;
                gap: 1rem;
            }

            .nav-menu {
                gap: 1rem;
            }

            .hero h1 {
                font-size: 2.5rem;
            }

            .hero-buttons {
                flex-direction: column;
                align-items: center;
            }

            .main-content {
                padding: 1rem;
            }

            .filters-header {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }

            .filter-buttons {
                justify-content: center;
            }

            .matches-grid {
                grid-template-columns: 1fr;
            }

            .teams {
                flex-direction: column;
                gap: 1rem;
            }

            .team.away {
                justify-content: center;
            }

            .vs {
                margin: 0;
            }

            .match-actions {
                flex-direction: column;
            }
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 1001;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: var(--success-color);
        }

        .notification.error {
            background: var(--error-color);
        }

        /* Reducir textos debajo de las tarjetas (20%) y ajustar ancho */
        .tile + div span:first-child {
            font-size: 0.72rem !important; /* antes 0.9rem */
            max-width: 173px !important;   /* alinear con width de .tile */
        }
        .tile + div span:last-child {
            font-size: 0.56rem !important; /* antes 0.7rem */
            max-width: 173px !important;
        }
        .tile + div {
            gap: 2px !important;
        }

        /* Ajustes de TENDENCIAS: 10% más grande y más juntas */
        #row-trending-top .row-track { gap: 1rem; }
        /* Forzar ancho de contenedores inline (de 216px a ~190px) */
        #row-trending-top .row-track > div[style*="width: 216px"] { width: 216px !important; }
        /* Reducir el gap vertical dentro de cada contenedor (de 6px a ~3px) */
        #row-trending-top .row-track > div[style*="gap: 6px"] { gap: 6px !important; }

        /* Tarjeta 10% más grande que el tamaño reducido previo */
        #row-trending-top .tile { width: 173px; height: 101px; }

        /* Textos debajo de las tarjetas +10% y ancho alineado */
        #row-trending-top .tile + div span:first-child { font-size: 0.72rem !important; max-width: 173px !important; }
        #row-trending-top .tile + div span:last-child  { font-size: 0.56rem !important; max-width: 173px !important; }

        /* Trending overrides back to original sizes */
        #row-trending-top .tile { width: 216px; height: 126px; }
        #row-trending-top .tile + div span:first-child { font-size: 0.9rem !important; max-width: 216px !important; }
        #row-trending-top .tile + div span:last-child  { font-size: 0.7rem !important; max-width: 216px !important; }

        /* removed duplicated trending row styles */
    </style>
</head>
<body>



    <!-- Main Content -->
    <main class="main-content">
        <!-- Loading -->
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Cargando partidos...</p>
        </div>

        <!-- Botón del carrusel movido aquí arriba -->
        <button class="carrusel-btn carrusel-next" id="carruselNext" onclick="moverCarrusel(1)" tabindex="13">
            ❯
        </button>

        <!-- Filtros Verticales -->
        <div class="vertical-filters">
            <div class="filter-group">
                <h3 class="filter-group-title">Estado</h3>
                <div class="vertical-filter-buttons">
                    <button class="vertical-filter-btn" onclick="filterByStatus('live')" title="En Vivo" tabindex="1">
                        <span class="filter-text">En Vivo</span>
                    </button>
                    <button class="vertical-filter-btn" onclick="filterByStatus('scheduled')" title="Programados" tabindex="2">
                        <span class="filter-text">Programados</span>
                    </button>
                    <button class="vertical-filter-btn" onclick="filterByStatus('finished')" title="Finalizados" tabindex="3">
                        <span class="filter-text">Finalizados</span>
                    </button>
                </div>
            </div>
            
            <div class="filter-group">
                <h3 class="filter-group-title">Deportes</h3>
                <div class="vertical-filter-buttons">
                    <button class="vertical-filter-btn" onclick="loadSport('football')" title="Fútbol" tabindex="4">
                        <span class="filter-text">Fútbol</span>
                    </button>
                    <button class="vertical-filter-btn" onclick="loadSport('basketball')" title="Baloncesto" tabindex="5">
                        <span class="filter-text">Baloncesto</span>
                    </button>
                    <button class="vertical-filter-btn" onclick="loadSport('cricket')" title="Cricket" tabindex="6">
                        <span class="filter-text">Cricket</span>
                    </button>
                </div>
            </div>
            
            <div class="filter-group">
                <h3 class="filter-group-title">Ligas</h3>
                <div class="vertical-filter-buttons">
                    <button class="vertical-filter-btn" onclick="filterByLeague('MLS')" title="MLS" tabindex="7">
                        <span class="filter-text">MLS</span>
                    </button>
                    <button class="vertical-filter-btn" onclick="filterByLeague('Premier League')" title="Premier League" tabindex="8">
                        <span class="filter-text">Premier</span>
                    </button>
                                        <button class="vertical-filter-btn" onclick="filterByLeague('La Liga')" title="La Liga" tabindex="9">
                        <span class="filter-text">La Liga</span>
                    </button>
            <button class="vertical-filter-btn" onclick="filterByChampionsLeague()" title="Champions League" tabindex="10">
                <span class="filter-text">Champions</span>
            </button>
                </div>
            </div>
        </div>

        <!-- Carrusel de Partidos -->
        <div class="carrusel-container">
            <div class="carrusel-wrapper" id="carruselWrapper">
                <div class="carrusel-track" id="carruselTrack">
                    <!-- Las tarjetas se cargarán aquí -->
                </div>
            </div>
            
            <!-- Botones de navegación -->
            <button class="carrusel-btn carrusel-prev" id="carruselPrev" onclick="moverCarrusel(-1)" style="display: none;" tabindex="12">
                ❮
            </button>
            
            <!-- Indicadores de página -->
            <div class="indicadores-pagina" id="indicadoresPagina">
                <!-- Los indicadores se generarán dinámicamente -->
            </div>
        </div>

        <!-- Trending Now -->
        <div class="row" id="row-trending-top">
            <h3>TENDENCIAS</h3>
            <div class="row-track" role="list">
                <!-- Las tarjetas se cargarán dinámicamente aquí -->
                <div style="display: flex; flex-direction: column; width: 216px; gap: 6px; overflow: hidden; flex-shrink: 0;"><button class="tile" role="listitem" tabindex="14">
                        <img src="https://streamed.pk/api/images/poster/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgqikIkQp65BgGNm4nvBFVuBLqzBhc+S0A/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgiIbCAggUIePXIMAxs3E94IqtwJdWYMLnw2gA.webp" alt="Vorskla Poltava W vs Lanchkhuti" onerror="this.onerror=null; this.src='https://koogle.com/images/fallback.webp';" onload="this.nextElementSibling.style.display='none';">
                        <div style="background: rgb(45, 45, 45); width: 100%; height: 100%; display: none; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 2rem;">⚽</div>
                        <div class="viewer-count" style="position: absolute; top: 8px; right: 8px; background: #111111; color: #ffffff; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; z-index: 10;">0</div>
                    </button><div style="display: flex; flex-direction: column; gap: 2px;"><span style="color: rgb(255, 255, 255); font-size: 0.9rem; font-weight: 700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">orskla Polta a W vs Lanchkhuti</span><span style="color: rgb(179, 179, 179); font-size: 0.7rem; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Fútbol • 0 espectadores</span></div></div><div style="display: flex; flex-direction: column; width: 216px; gap: 6px; overflow: hidden; flex-shrink: 0;"><button class="tile" role="listitem" tabindex="14">
                        <img src="https://streamed.pk/api/images/poster/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgiIGCFWqY9cgwDGzcT3giq3Al1ZgwufFaA/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgqIIiGwh1EeuQYBjZuJ7wRVbgS6swYXPmtA.webp" alt="BIIK Kazygurt vs GKS Katowice W" onerror="this.onerror=null; this.src='https://koogle.com/images/fallback.webp';" onload="this.nextElementSibling.style.display='none';">
                        <div style="background: rgb(45, 45, 45); width: 100%; height: 100%; display: none; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 2rem;">⚽</div>
                        <div class="viewer-count" style="position: absolute; top: 8px; right: 8px; background: #111111; color: #ffffff; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; z-index: 10;">0</div>
                    </button><div style="display: flex; flex-direction: column; gap: 2px;"><span style="color: rgb(255, 255, 255); font-size: 0.9rem; font-weight: 700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">BIIK Kazygurt vs GKS Katowice W</span><span style="color: rgb(179, 179, 179); font-size: 0.7rem; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Fútbol • 0 espectadores</span></div></div><div style="display: flex; flex-direction: column; width: 216px; gap: 6px; overflow: hidden; flex-shrink: 0;"><button class="tile" role="listitem" tabindex="14">
                        <img src="https://streamed.pk/api/images/poster/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgiIGCBQgqIePXIMAxs3E94IqtwJdWYMLnw2gA/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgqIIiGwh1TOuQYBjZuJ7wRVbgS6swYXPmtA.webp" alt="Slavia Praha W vs Fomget Gençlik" onerror="this.onerror=null; this.src='https://koogle.com/images/fallback.webp';" onload="this.nextElementSibling.style.display='none';">
                        <div style="background: rgb(45, 45, 45); width: 100%; height: 100%; display: none; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 2rem;">⚽</div>
                        <div class="viewer-count" style="position: absolute; top: 8px; right: 8px; background: #111111; color: #ffffff; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; z-index: 10;">0</div>
                    </button><div style="display: flex; flex-direction: column; gap: 2px;"><span style="color: rgb(255, 255, 255); font-size: 0.9rem; font-weight: 700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Sla ia Praha W vs Fomget Gençlik</span><span style="color: rgb(179, 179, 179); font-size: 0.7rem; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Fútbol • 0 espectadores</span></div></div><div style="display: flex; flex-direction: column; width: 216px; gap: 6px; overflow: hidden; flex-shrink: 0;"><button class="tile" role="listitem" tabindex="14">
                        <img src="https://streamed.pk/api/images/poster/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgiikDBABjENnrkGa5uJ7wRVbgS6swYXPmtA/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgiIFCFWJ+9cgwDGzcT3giq3Al1ZgwufFaA.webp" alt="Rosengård W vs Ljuboten W" onerror="this.onerror=null; this.src='https://koogle.com/images/fallback.webp';" onload="this.nextElementSibling.style.display='none';">
                        <div style="background: rgb(45, 45, 45); width: 100%; height: 100%; display: none; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 2rem;">⚽</div>
                        <div class="viewer-count" style="position: absolute; top: 8px; right: 8px; background: #111111; color: #ffffff; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; z-index: 10;">0</div>
                    </button><div style="display: flex; flex-direction: column; gap: 2px;"><span style="color: rgb(255, 255, 255); font-size: 0.9rem; font-weight: 700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Rosengård W vs Ljuboten W</span><span style="color: rgb(179, 179, 179); font-size: 0.7rem; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Fútbol • 0 espectadores</span></div></div><div style="display: flex; flex-direction: column; width: 216px; gap: 6px; overflow: hidden; flex-shrink: 0;"><button class="tile" role="listitem" tabindex="14">
                        <img src="https://streamed.pk/api/images/poster/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgiIGCBSKQEeuQYBjZuJ7wRVbgS6swYXPmtA/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgqIIiAgh1EeuQYBjZuJ7wRVbgS6swYXPmtA.webp" alt="Breidablik W vs Athlone WFC W" onerror="this.onerror=null; this.src='https://koogle.com/images/fallback.webp';" onload="this.nextElementSibling.style.display='none';">
                        <div style="background: rgb(45, 45, 45); width: 100%; height: 100%; display: none; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 2rem;">⚽</div>
                        <div class="viewer-count" style="position: absolute; top: 8px; right: 8px; background: #111111; color: #ffffff; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; z-index: 10;">0</div>
                    </button><div style="display: flex; flex-direction: column; gap: 2px;"><span style="color: rgb(255, 255, 255); font-size: 0.9rem; font-weight: 700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Breidablik W vs Athlone WFC W</span><span style="color: rgb(179, 179, 179); font-size: 0.7rem; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Fútbol • 0 espectadores</span></div></div><div style="display: flex; flex-direction: column; width: 216px; gap: 6px; overflow: hidden; flex-shrink: 0;"><button class="tile" role="listitem" tabindex="14">
                        <img src="https://streamed.pk/api/images/poster/GwZg7AZpYEZgHCAjAJgCzrAY29lBWSUYAUwVmDTAE5p5gJhqDh61hh1OPgBDYLKQRcOJBt16ZGY-p3bU+4wSXQgYIFEUZsQvEFhAkQEEABN9IRAcTwCFfAJQ8wZeEQVinD+mBfixEEA/GwZg7AZpYEZgHCAjAJgCzrAThFlBWSUYAUwVmDW2nmAmD32FrWGHXbeAENgBjUgg5sSdTt0z1Rvdqyw8xAkuhBwYIACYgl2kNxAkQiQ3xBmUesyAgEKTPii5gy8IvNGOmtMM7GiIQA.webp" alt="Krylia Sovetov Samara vs Dynamo Moscow" onerror="this.onerror=null; this.src='https://koogle.com/images/fallback.webp';" onload="this.nextElementSibling.style.display='none';">
                        <div style="background: rgb(45, 45, 45); width: 100%; height: 100%; display: none; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 2rem;">⚽</div>
                        <div class="viewer-count" style="position: absolute; top: 8px; right: 8px; background: #111111; color: #ffffff; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; z-index: 10;">0</div>
                    </button><div style="display: flex; flex-direction: column; gap: 2px;"><span style="color: rgb(255, 255, 255); font-size: 0.9rem; font-weight: 700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Krylia So eto Samara vs Dynamo Moscow</span><span style="color: rgb(179, 179, 179); font-size: 0.7rem; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Fútbol • 0 espectadores</span></div></div><div style="display: flex; flex-direction: column; width: 216px; gap: 6px; overflow: hidden; flex-shrink: 0;"><button class="tile" role="listitem" tabindex="14">
                        <img src="https://streamed.pk/api/images/poster/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgiIGCBSLF9cgwDGzcT3giq3Al1ZgwufFaA/GwZg7AZpYEZgHCAjAJgCzuFgpsCwVgBDQhWYNMATkhQFZgrDh49g773hta1gATChUiNiwMOPQjcRLAnQgiIAMYhE-FfXINlzcT3giq3Al1ZgwufFaA.webp" alt="Apollon Limassol W vs Young Boys W" onerror="this.onerror=null; this.src='https://koogle.com/images/fallback.webp';" onload="this.nextElementSibling.style.display='none';">
                        <div style="background: rgb(45, 45, 45); width: 100%; height: 100%; display: none; alignitems: center; justify-content: center; color: white; font-weight: bold; font-size: 2rem;">⚽</div>
                        <div class="viewer-count" style="position: absolute; top: 8px; right: 8px; background: #ff6b35; color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: bold; z-index: 10;">👁️ 0</div>
                    </button><div style="display: flex; flex-direction: column; gap: 2px;"><span style="color: rgb(255, 255, 255); font-size: 0.9rem; font-weight: 700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Apollon Limassol W vs Young Boys W</span><span style="color: rgb(179, 179, 179); font-size: 0.7rem; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 216px;">Fútbol • 0 espectadores</span></div></div>
            </div>
        </div>

        

          <!-- Apps -->
          <div class="row" id="row-apps">
              <div class="row-track apps">
                  <button class="app-icon" tabindex="0" aria-label="Netflix" style="background:#e50914;">Netflix</button>
                  <button class="app-icon" tabindex="0" aria-label="YouTube" style="background:#fff; color:#000;">YouTube</button>
                  <button class="app-icon" tabindex="0" aria-label="Disney+" style="background:#0b1736;">Disney+</button>
                  <button class="app-icon" tabindex="0" aria-label="Max" style="background:#0a0a4a;">Max</button>
                  <button class="app-icon" tabindex="0" aria-label="Apple TV" style="background:#000;" onclick="openExternalOverlay('applemejorado.html')">tv</button>
                  <button class="app-icon" tabindex="0" aria-label="Hulu" style="background:#1ce783; color:#062a15;">hulu</button>
                  <button class="app-icon" tabindex="0" aria-label="Peacock" style="background:#111;">peacock</button>
                  <button class="app-icon" tabindex="0" aria-label="Paramount+" style="background:#0064ff;">Paramount+</button>
                  <button class="app-icon" tabindex="0" aria-label="Prime Video" style="background:#00a8e1;">Prime</button>
                  <button class="app-icon" tabindex="0" aria-label="Roku" style="background:#6f1ab1;">Roku</button>
                  <button class="app-icon" tabindex="0" aria-label="Plex" style="background:#1f1f1f;">Plex</button>
                  <button class="app-icon" tabindex="0" aria-label="iHeart" style="background:#c6002b;">iHeart</button>
            </div>
        </div>
    </main>

    <!-- Streams Modal -->
    <div class="modal" id="streamsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">Streams Disponibles</h3>
                <button class="close-btn" onclick="closeModal()">&times;</button>
            </div>
            <div class="streams-list" id="streamsList">
                <!-- Streams will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Universal Stream Overlay -->
    <div class="stream-overlay" id="streamOverlay">
        <div class="stream-overlay-content">
            <!-- Botón de cerrar -->
            <button id="closeStreamBtn" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; border: 2px solid white; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; font-weight: bold; cursor: pointer; z-index: 10001; display: flex; align-items: center; justify-content: center;" onclick="closeStreamOverlay()">×</button>
            
            <div class="stream-overlay-body">
                <iframe id="streamIframe" src="" frameborder="0" allowfullscreen></iframe>
            </div>
            
        </div>
    </div>



    <script>
        let allMatches = [];
        let currentMatches = [];
        let currentFilter = 'all';
        let currentSport = 'football';
        let mlsTeams = []; // Array para almacenar equipos de MLS

        // Función para obtener equipos de MLS desde ESPN API
        async function loadMLSTeams() {
            try {
                console.log('🔍 Cargando equipos de MLS desde ESPN API...');
                
                // URL de la API de ESPN para MLS
                const response = await fetch('https://site.api.espn.com/apis/site/v2/sports/soccer/usa.1/teams');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.sports && data.sports[0] && data.sports[0].leagues && data.sports[0].leagues[0] && data.sports[0].leagues[0].teams) {
                    mlsTeams = data.sports[0].leagues[0].teams.map(team => ({
                        name: team.team.name,
                        abbreviation: team.team.abbreviation,
                        displayName: team.team.displayName,
                        shortName: team.team.shortName
                    }));
                    
                    console.log('✅ Equipos de MLS cargados:', mlsTeams.length);
                    console.log('📋 Lista de equipos MLS:', mlsTeams.map(t => t.name));
                    
                    return mlsTeams;
                } else {
                    throw new Error('Estructura de datos inesperada en ESPN API');
                }
                
            } catch (error) {
                console.error('❌ Error cargando equipos MLS:', error);
                
                // Fallback con equipos MLS conocidos
                mlsTeams = [
                    { name: 'Atlanta United FC', abbreviation: 'ATL' },
                    { name: 'Austin FC', abbreviation: 'AUS' },
                    { name: 'Charlotte FC', abbreviation: 'CLT' },
                    { name: 'Chicago Fire FC', abbreviation: 'CHI' },
                    { name: 'Colorado Rapids', abbreviation: 'COL' },
                    { name: 'Columbus Crew', abbreviation: 'CLB' },
                    { name: 'D.C. United', abbreviation: 'DC' },
                    { name: 'FC Cincinnati', abbreviation: 'CIN' },
                    { name: 'FC Dallas', abbreviation: 'DAL' },
                    { name: 'Houston Dynamo FC', abbreviation: 'HOU' },
                    { name: 'Inter Miami CF', abbreviation: 'MIA' },
                    { name: 'LA Galaxy', abbreviation: 'LA' },
                    { name: 'Los Angeles FC', abbreviation: 'LAFC' },
                    { name: 'Minnesota United FC', abbreviation: 'MIN' },
                    { name: 'Montreal Impact', abbreviation: 'MTL' },
                    { name: 'Nashville SC', abbreviation: 'NSH' },
                    { name: 'New England Revolution', abbreviation: 'NE' },
                    { name: 'New York City FC', abbreviation: 'NYC' },
                    { name: 'New York Red Bulls', abbreviation: 'NY' },
                    { name: 'Orlando City SC', abbreviation: 'ORL' },
                    { name: 'Philadelphia Union', abbreviation: 'PHI' },
                    { name: 'Portland Timbers', abbreviation: 'POR' },
                    { name: 'Real Salt Lake', abbreviation: 'RSL' },
                    { name: 'San Jose Earthquakes', abbreviation: 'SJ' },
                    { name: 'Seattle Sounders FC', abbreviation: 'SEA' },
                    { name: 'Sporting Kansas City', abbreviation: 'SKC' },
                    { name: 'Toronto FC', abbreviation: 'TOR' },
                    { name: 'Vancouver Whitecaps FC', abbreviation: 'VAN' },
                    { name: 'St. Louis City SC', abbreviation: 'STL' }
                ];
                
                console.log('🔄 Usando lista fallback de equipos MLS:', mlsTeams.length);
                return mlsTeams;
            }
        }

        // Función para verificar si un partido es de MLS
        function isMLSMatch(match) {
            if (!mlsTeams || mlsTeams.length === 0) {
                console.log('❌ No hay equipos MLS cargados');
                return false;
            }
            
            let homeTeam = '';
            let awayTeam = '';
            
            // Extraer nombres de equipos
            if (match.teams) {
                try {
                    const teams = typeof match.teams === 'string' ? JSON.parse(match.teams) : match.teams;
                    if (teams.home && teams.home.name) {
                        homeTeam = teams.home.name.toLowerCase();
                    }
                    if (teams.away && teams.away.name) {
                        awayTeam = teams.away.name.toLowerCase();
                    }
                } catch (e) {
                    console.error('Error parseando teams:', e.message);
                }
            }
            
            // Si no hay equipos, intentar extraer del título
            if (!homeTeam && !awayTeam && match.title) {
                const title = match.title.toLowerCase();
                if (title.includes(' vs ')) {
                    const parts = title.split(' vs ');
                    homeTeam = parts[0].trim();
                    awayTeam = parts[1].trim();
                }
            }
            
            // Verificar si alguno de los equipos es de MLS
            const isMLS = mlsTeams.some(mlsTeam => {
                const mlsName = mlsTeam.name.toLowerCase();
                const matchFound = homeTeam.includes(mlsName) || awayTeam.includes(mlsName) ||
                       mlsName.includes(homeTeam) || mlsName.includes(awayTeam);
                
                if (matchFound) {
                    console.log(`✅ Partido MLS encontrado: ${homeTeam} vs ${awayTeam} (coincide con: ${mlsName})`);
                }
                
                return matchFound;
            });
            
            if (!isMLS && (homeTeam || awayTeam)) {
                console.log(`❌ No es MLS: ${homeTeam} vs ${awayTeam}`);
            }
            
            return isMLS;
        }

        // Utility Functions
        function showLoading(show) {
            // Deshabilitado para evitar movimiento del contenedor
            // document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function showNotification(message, type = 'success') {
            // Notificaciones desactivadas por solicitud
            return;
        }

        function formatDate(dateString) {
            if (!dateString) return 'Fecha no disponible';
            
            try {
                let date;
                if (typeof dateString === 'number') {
                    date = new Date(dateString);
                } else {
                    date = new Date(dateString);
                }
                
                if (isNaN(date.getTime())) return 'Fecha inválida';
                
                return date.toLocaleString('es-ES', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                return 'Error de fecha';
            }
        }

        function getMatchStatus(match) {
            if (match.status) return match.status;
            
            // Usar time o date, cualquiera que esté disponible
            const matchTime = match.time || match.date;
            
            if (matchTime) {
                const now = new Date();
                let parsedTime;
                
                if (typeof matchTime === 'number') {
                    parsedTime = new Date(matchTime);
                } else {
                    parsedTime = new Date(matchTime);
                }
                
                if (isNaN(parsedTime.getTime())) return 'unknown';
                
                const timeDiff = parsedTime - now;
                const hoursDiff = timeDiff / (1000 * 60 * 60);
                
                // Si es futuro (más de 1 hora adelante)
                if (hoursDiff > 1) return 'scheduled';
                
                // Si está en vivo (entre -3 horas y +1 hora)
                if (hoursDiff >= -3 && hoursDiff <= 1) return 'live';
                
                // Si es pasado (más de 3 horas atrás)
                return 'finished';
            }
            
            return 'unknown';
        }



        function loadTeamBadge(badgeId, elementId) {
            try {
                const logoElement = document.getElementById(elementId);
                if (logoElement) {
                    const imageUrl = `https://streamed.pk/api/images/proxy/${badgeId}.webp`;
                    logoElement.innerHTML = `<img src="${imageUrl}" alt="Team Logo" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">`;
                }
            } catch (error) {
                console.error(`Error cargando badge ${badgeId}:`, error.message);
            }
        }

        function limpiarNombreEquipo(nombre) {
            if (!nombre) return 'Equipo';
            
            let nombreLimpio = nombre.trim();
            
            // Remover información extra común
            const patronesARemover = [
                /\([^)]*\)/g,  // Paréntesis y su contenido
                /\[[^\]]*\]/g,  // Corchetes y su contenido
                /\d{1,2}:\d{2}/g,  // Horarios (HH:MM)
                /\d{1,2}:\d{2}\s*(AM|PM)/gi,  // Horarios con AM/PM
                /vs\.?/gi,  // "vs" o "vs."
                /v\.?/gi,   // "v" o "v."
                /-\s*$/g,   // Guión al final
                /^\s*-\s*/g, // Guión al inicio
                /\s+/g      // Múltiples espacios
            ];
            
            patronesARemover.forEach(patron => {
                nombreLimpio = nombreLimpio.replace(patron, ' ');
            });
            
            // Limpiar espacios extra
            nombreLimpio = nombreLimpio.trim();
            
            // Si quedó vacío, usar nombre original
            if (!nombreLimpio) {
                nombreLimpio = nombre.trim();
            }
            
            // Limitar longitud
            if (nombreLimpio.length > 30) {
                nombreLimpio = nombreLimpio.substring(0, 30) + '...';
            }
            
            return nombreLimpio;
        }

        function extractTeamsFromTitle(title) {
            if (!title || typeof title !== 'string') return null;
            const normalized = title
                .replace(/\s+vs\.?\s+/i, ' vs ')
                .replace(/\s+v\.?\s+/i, ' vs ')
                .replace(/\s+-\s+/g, ' vs ')
                .replace(/\s+—\s+/g, ' vs ')
                .replace(/\s+at\s+/i, ' vs ');
            const parts = normalized.split(' vs ');
            if (parts.length === 2) {
                return [parts[0].trim(), parts[1].trim()];
            }
            return null;
        }

        // Normalizar nombres de equipos al español (solo equipos; competencias se mantienen normales)
        function normalizeTeamSpanish(name) {
            if (!name || typeof name !== 'string') return name;
            let n = name.trim();
            const lower = n.toLowerCase();
            // Mapeos puntuales comunes
            if (/(red\s*star\s*belgrade|crvena\s*zvezda)/i.test(lower)) return 'Estrella Roja';
            if (/bodo\/?glimt|bodø\/?glimt/i.test(lower)) return 'Bodø/Glimt';
            if (/kairat\s*almaty/i.test(lower)) return 'Kairat';
            // Dejar el resto igual
            return n;
        }

        function createMatchCard(match) {
            const status = getMatchStatus(match);
            const statusText = {
                'live': 'EN VIVO',
                'scheduled': 'PROGRAMADO',
                'finished': 'FINALIZADO',
                'unknown': 'DESCONOCIDO'
            };

            // Extract team information
            let homeTeam = 'Equipo Local';
            let awayTeam = 'Equipo Visitante';
            let homeBadge = null;
            let awayBadge = null;

            // Primero intentar extraer del campo teams
            if (match.teams) {
                try {
                    const teams = typeof match.teams === 'string' ? JSON.parse(match.teams) : match.teams;
                    if (teams.home && teams.home.name) {
                        homeTeam = teams.home.name;
                        homeBadge = teams.home.badge;
                    }
                    if (teams.away && teams.away.name) {
                        awayTeam = teams.away.name;
                        awayBadge = teams.away.badge;
                    }
                } catch (e) {
                    console.error('Error parseando teams:', e.message);
                }
            }

            // Si no se encontraron equipos, intentar extraer del título (robusto)
            if (homeTeam === 'Equipo Local' && awayTeam === 'Equipo Visitante' && match.title) {
                const parsed = extractTeamsFromTitle(match.title);
                if (parsed) {
                    homeTeam = parsed[0];
                    awayTeam = parsed[1];
                    console.log('✅ Equipos extraídos (robusto):', homeTeam, 'vs', awayTeam);
                } else {
                    const title = match.title;
                    if (title.includes(' vs ')) {
                        const parts = title.split(' vs ');
                        if (parts.length === 2) {
                            homeTeam = parts[0].trim();
                            awayTeam = parts[1].trim();
                        }
                    } else if (title.includes(' - ') && !title.includes(' vs ')) {
                        const parts = title.split(' - ');
                        if (parts.length === 2) {
                            homeTeam = parts[0].trim();
                            awayTeam = parts[1].trim();
                        }
                    } else if (title.includes(' v ')) {
                        const parts = title.split(' v ');
                        if (parts.length === 2) {
                            homeTeam = parts[0].trim();
                            awayTeam = parts[1].trim();
                        }
                    } else {
                        homeTeam = title;
                        awayTeam = 'vs';
                    }
                }

                // Limpiar nombres de equipos
                homeTeam = limpiarNombreEquipo(homeTeam);
                awayTeam = limpiarNombreEquipo(awayTeam);
            }

            // Normalizar equipos a español (solo equipos)
            homeTeam = normalizeTeamSpanish(homeTeam);
            awayTeam = normalizeTeamSpanish(awayTeam);

            const league = match.league || match.competition || match.tournament || match.event || match.category || 'Liga';
            const sources = match.sources || match.streams || [];
            
            // Obtener URL de la imagen del partido usando la API de Streamed correctamente
            let posterUrl = null;
            
            // 1. Intentar usar el poster del partido si existe
            if (match.poster) {
                // Si el poster ya es una URL completa (como https://ppv.to/...)
                if (match.poster.startsWith('http')) {
                    posterUrl = match.poster;
                    console.log('🖼️ Usando poster externo:', posterUrl);
                }
                // Si el poster es una ruta relativa de Streamed
                else {
                    // Si ya incluye /api/images/poster/ o /api/images/proxy/
                    if (match.poster.startsWith('/api/images/poster/')) {
                        posterUrl = `https://streamed.pk${match.poster}`;
                    } else if (match.poster.startsWith('api/images/poster/')) {
                        posterUrl = `https://streamed.pk/${match.poster}`;
                    } else if (match.poster.startsWith('/api/images/proxy/')) {
                        posterUrl = `https://streamed.pk${match.poster}`;
                    } else if (match.poster.startsWith('api/images/proxy/')) {
                        posterUrl = `https://streamed.pk/${match.poster}`;
                    } else {
                        // Si es solo el ID, agregar la ruta completa usando proxy (seguro)
                        posterUrl = `https://streamed.pk/api/images/proxy/${match.poster}`;
                    }
                    console.log('🖼️ Usando poster de Streamed:', posterUrl);
                }
            }
            // 2. Intentar construir poster compuesto como en el principal: /api/images/poster/{home}/{away}.webp
            else if (match?.teams?.home?.badge && match?.teams?.away?.badge) {
                const home = match.teams.home.badge;
                const away = match.teams.away.badge;
                posterUrl = `https://streamed.pk/api/images/poster/${home}/${away}.webp`;
                console.log('🖼️ Usando poster compuesto:', posterUrl);
            }
            // 3. Si no hay poster, intentar usar el badge del equipo local
            else if (match?.teams?.home?.badge) {
                posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.home.badge}.webp`;
                console.log('🖼️ Usando badge equipo local:', posterUrl);
            }
            // 4. Si no hay badge del equipo local, intentar con el equipo visitante
            else if (match?.teams?.away?.badge) {
                posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.away.badge}.webp`;
                console.log('🖼️ Usando badge equipo visitante:', posterUrl);
            }
            // 5. Si no hay estructura teams, intentar generar un badge basado en el título
            else if (match.title) {
                // Generar un hash simple del título para crear un badge único
                const titleHash = btoa(match.title).replace(/[^a-zA-Z0-9]/g, '').substring(0, 20);
                posterUrl = `https://streamed.pk/api/images/proxy/${titleHash}.webp`;
                console.log('🖼️ Usando badge generado del título:', posterUrl);
            }
            else {
                console.log('❌ No se encontró imagen para:', match.title, 'Teams:', match.teams);
            }

            const card = document.createElement('div');
            card.className = 'match-card';
            card.setAttribute('data-match-id', match.id || 'unknown');
            card.setAttribute('data-status', status);

            // Precompute stable logo IDs
            const safeId = (match.id || String(Math.random()).slice(2)).toString().replace(/[^a-zA-Z0-9_-]/g, '');
            const homeLogoId = `home-logo-${safeId}`;
            const awayLogoId = `away-logo-${safeId}`;
            
            // Poster images removed - user will add their own
            card.classList.add('no-poster');
            
            card.innerHTML += `
                <div class="match-overlay">
                    <div class="contenido-texto">
                        <div class="branding">Koogle TV</div>
                        <h2>${homeTeam} vs ${awayTeam}</h2>
                        <div class="metadata">
                            <span>${formatDate(match.date || match.time)}</span>
                            <span class="bullet">•</span>
                            <span>${league}</span>
                            <span class="bullet">•</span>
                            <span class="status-${status}">${statusText[status]}</span>
                        </div>
                        <p>Disfruta de la pasión del fútbol en su máxima expresión. Partidos llenos de emoción, goles espectaculares y momentos inolvidables que te mantendrán al borde del asiento.</p>
                        <div class="botones-container">
                            <button class="action-btn btn-watch" onclick="showStreams('${match.id}', '${homeTeam} vs ${awayTeam}')" tabindex="0">
                                <span style="position: relative; z-index: 2;">VER AHORA</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Load team badges with stable IDs
            if (homeBadge) {
                loadTeamBadge(homeBadge, homeLogoId);
            }
            if (awayBadge) {
                loadTeamBadge(awayBadge, awayLogoId);
            }
            
            return card;
        }

        let currentSlide = 0;
        let totalSlides = 0;

        function displayMatches(matches) {
            const track = document.getElementById('carruselTrack');
            track.innerHTML = '';
            
            if (matches.length === 0) {
                track.innerHTML = `
                    <div class="empty-state" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: white;">
                        <div class="empty-icon" style="font-size: 4rem; margin-bottom: 1rem;">⚽</div>
                        <h3>No se encontraron partidos</h3>
                        <p>Intenta con otros filtros o deportes</p>
                    </div>
                `;
                return;
            }
            
            // Usar todos los partidos disponibles en el carrusel
            const matchesToShow = matches;
            totalSlides = matchesToShow.length;
            currentSlide = 0;
            
            matchesToShow.forEach(match => {
                const card = createMatchCard(match);
                track.appendChild(card);
            });
            
            // Actualizar indicadores
            actualizarIndicadores();
            // Mostrar primera tarjeta
            mostrarSlide(0);
        }

        function normalizeToDate(value) {
            try {
                if (!value) return null;
                if (typeof value === 'number') {
                    // Aceptar epoch en segundos o milisegundos
                    const ms = value < 1e12 ? value * 1000 : value;
                    const d = new Date(ms);
                    return isNaN(d.getTime()) ? null : d;
                }
                if (typeof value === 'string') {
                    const d = new Date(value);
                    // Si falla parseo directo, intentar como número
                    if (isNaN(d.getTime())) {
                        const num = Number(value);
                        if (!isNaN(num)) {
                            const ms = num < 1e12 ? num * 1000 : num;
                            const d2 = new Date(ms);
                            return isNaN(d2.getTime()) ? null : d2;
                        }
                    }
                    return isNaN(d.getTime()) ? null : d;
                }
                if (value instanceof Date) {
                    return isNaN(value.getTime()) ? null : value;
                }
                return null;
            } catch (_) { return null; }
        }

        function isSameLocalDay(a, b) {
            return a.getFullYear() === b.getFullYear() &&
                   a.getMonth() === b.getMonth() &&
                   a.getDate() === b.getDate();
        }

        function filterMatchesForDate(matches, targetDate) {
            return matches.filter(match => {
                const raw = match.date ?? match.time ?? match.startTime ?? null;
                const d = normalizeToDate(raw);
                return d ? isSameLocalDay(d, targetDate) : false;
            });
        }

        function filterMatchesForHour(matches, targetHour) {
            return matches.filter(match => {
                const raw = match.date ?? match.time ?? match.startTime ?? null;
                const d = normalizeToDate(raw);
                return d ? d.getHours() === targetHour : false;
            });
        }

        async function loadMatches(sport = 'football') {
            try {
                // Primero cargar equipos de MLS
                await loadMLSTeams();
                
                console.log('🔍 Cargando partidos desde Streamed API...');
                const response = await fetch(`https://streamed.pk/api/matches/${sport}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const matches = await response.json();
                
                if (!Array.isArray(matches)) {
                    throw new Error('La respuesta no es un array de partidos');
                }
                
                console.log(`📊 Total de partidos recibidos: ${matches.length}`);
                
                // Diagnóstico de categorías
                logCategoryDiagnostics(matches);
                
                // Usar todos los partidos
                allMatches = matches;
                
                // Enriquecer competiciones consultando diario externo (ftvhd) y asignar overrides por coincidencia
                const diary = await fetchDiaryToday();
                diaryAssignCompetitionsForToday(allMatches, diary);
                
                const now = new Date();
                
                // Filtrar solo los de HOY (hora local)
                const todayMatches = filterMatchesForDate(allMatches, now);
                console.log(`📅 Partidos de HOY: ${todayMatches.length}`);
                
                // Guardar todos los partidos de HOY pero NO mostrarlos automáticamente
                currentMatches = todayMatches;
                
                currentSport = sport;
                
                displayMatches(currentMatches);
                
                // Actualizar sección de tendencias con partidos populares de HOY
                await updateTrendingSection();
                
            } catch (error) {
                console.error('Error loading matches:', error);
                displayMatches([]);
            }
        }

        function loadAllMatches() {
            loadMatches(currentSport);
        }

        // Funciones del carrusel
        function moverCarrusel(direccion) {
            // Verificar si el botón del carrusel está enfocado
            const focusedElement = document.activeElement;
            const isCarouselButtonFocused = focusedElement && 
                (focusedElement.id === 'carruselNext' || focusedElement.id === 'carruselPrev');
            
            // Solo mover si el botón está enfocado
            if (!isCarouselButtonFocused) {
                console.log('🚫 Carrusel no movido: botón no enfocado');
                return;
            }
            
            const nuevaPosicion = currentSlide + direccion;
            
            if (nuevaPosicion >= 0 && nuevaPosicion < totalSlides) {
                mostrarSlide(nuevaPosicion);
                console.log('✅ Carrusel movido:', direccion > 0 ? 'siguiente' : 'anterior');
            }
        }

        function mostrarSlide(indice) {
            if (indice < 0 || indice >= totalSlides) return;
            
            currentSlide = indice;
            const track = document.getElementById('carruselTrack');
            const translateX = -indice * 100;
            track.style.transform = `translateX(${translateX}%)`;
            
            // Actualizar indicadores
            actualizarIndicadores();
            
            // Mostrar/ocultar botones según la posición
            const prevBtn = document.getElementById('carruselPrev');
            const nextBtn = document.getElementById('carruselNext');
            
            // Solo ocultar el botón prev si está dentro del carrusel
            if (prevBtn && prevBtn.closest('.carrusel-container')) {
            prevBtn.style.display = indice === 0 ? 'none' : 'block';
            }
            
            // No ocultar el botón next ya que está fuera del carrusel
            // nextBtn.style.display = indice === totalSlides - 1 ? 'none' : 'block';
        }

        function actualizarIndicadores() {
            const indicadoresContainer = document.getElementById('indicadoresPagina');
            indicadoresContainer.innerHTML = '';
            
            // Limitar a máximo 10 indicadores para evitar desbordamiento
            const maxIndicators = Math.min(totalSlides, 10);
            for (let i = 0; i < maxIndicators; i++) {
                const indicador = document.createElement('div');
                // Hacer indicadores circulares: si currentSlide > 9, mostrar activo en posición (currentSlide % 10)
                const activeIndicator = currentSlide >= 10 ? (currentSlide % 10) : currentSlide;
                indicador.className = `indicador ${i === activeIndicator ? 'activo' : ''}`;
                indicador.onclick = () => mostrarSlide(i);
                indicadoresContainer.appendChild(indicador);
            }
        }



        function loadLiveMatches() {
            const liveMatches = allMatches.filter(match => getMatchStatus(match) === 'live');
            currentMatches = liveMatches;
            displayMatches(liveMatches);
            showNotification(`${liveMatches.length} partidos en vivo encontrados`, 'success');
        }

        function loadSport(sport) {
            loadMatches(sport);
        }

        function filterByStatus(status, event = null) {
            currentFilter = status;
            
            // Update filter buttons
            document.querySelectorAll('.vertical-filter-btn').forEach(btn => btn.classList.remove('active'));
            
            // Solo agregar clase active si hay un evento (click del usuario)
            if (event && event.target) {
            event.target.classList.add('active');
            } else {
                // Si no hay evento, buscar el botón correspondiente y activarlo
                const liveButton = document.querySelector(`[onclick*="filterByStatus('live')"]`);
                if (liveButton && status === 'live') {
                    liveButton.classList.add('active');
                }
            }
            
            let filteredMatches = [];
            
            if (status === 'live') {
                // Para partidos en vivo: usar la función getMatchStatus pero con filtro manual adicional
                const now = new Date();
                filteredMatches = allMatches.filter(match => {
                    // Primero verificar si getMatchStatus dice que está en vivo
                    const isLiveByStatus = getMatchStatus(match) === 'live';
                    
                    if (!isLiveByStatus) return false;
                    
                    // Si no tiene tiempo, incluirlo si getMatchStatus dice que está en vivo
                    if (!match.time) return true;
                    
                    const matchTime = new Date(match.time);
                    const timeDiff = now - matchTime;
                    const hoursDiff = timeDiff / (1000 * 60 * 60);
                    
                    // Solo partidos que empezaron hace menos de 2 horas
                    return hoursDiff >= 0 && hoursDiff <= 2;
                });
                
                // Ordenar por horario (más recientes primero)
                filteredMatches.sort((a, b) => {
                    if (!a.time && !b.time) return 0;
                    if (!a.time) return 1;
                    if (!b.time) return -1;
                    
                    const timeA = new Date(a.time);
                    const timeB = new Date(b.time);
                    return timeB - timeA; // Orden descendente (más reciente primero)
                });
                
                console.log(`🔴 Partidos en vivo (últimas 2 horas): ${filteredMatches.length}`);
                
                // Debug: mostrar todos los partidos y su estado
                console.log('🔍 Debug - Todos los partidos y su estado:');
                allMatches.slice(0, 10).forEach((match, index) => {
                    const status = getMatchStatus(match);
                    const timeStr = match.time ? new Date(match.time).toLocaleString() : 'Sin tiempo';
                    console.log(`  ${index + 1}. ${match.title} - ${timeStr} -> Estado: ${status}`);
                });
                
                filteredMatches.forEach((match, index) => {
                    const timeStr = match.time ? new Date(match.time).toLocaleString() : 'Sin tiempo';
                    console.log(`  ${index + 1}. ${match.title} - ${timeStr}`);
                });
                
            } else {
                // Para otros estados: usar la función getMatchStatus normal
                filteredMatches = allMatches.filter(match => getMatchStatus(match) === status);
                
                // Ordenar por horario (ascendente - más temprano primero)
                filteredMatches.sort((a, b) => {
                    if (!a.time && !b.time) return 0;
                    if (!a.time) return 1;
                    if (!b.time) return -1;
                    
                    const timeA = new Date(a.time);
                    const timeB = new Date(b.time);
                    return timeA - timeB; // Orden ascendente
                });
            }
            
            currentMatches = filteredMatches;
            displayMatches(filteredMatches);
            
            showNotification(`${filteredMatches.length} partidos ${status}`, 'success');
        }

        function filterByLeague(leagueName, event = null) {
            // Update filter buttons
            document.querySelectorAll('.vertical-filter-btn').forEach(btn => btn.classList.remove('active'));
            
            // Solo agregar clase active si hay un evento (click del usuario)
            if (event && event.target) {
            event.target.classList.add('active');
            }
            
            let filteredMatches = [];
            
            // Mostrar todos los partidos sin filtrar
            if (leagueName.toLowerCase() === 'mls') {
                filteredMatches = allMatches;
                console.log(`🔍 Mostrando todos los partidos: ${filteredMatches.length} partidos disponibles`);
            } else {
                // Filtro normal por nombre de liga
                filteredMatches = allMatches.filter(match => {
                    const matchLeague = match.league || match.competition || match.tournament || match.event || match.category || '';
                    return matchLeague.toLowerCase().includes(leagueName.toLowerCase());
                });
            }
            
            currentMatches = filteredMatches;
            displayMatches(filteredMatches);
            
            showNotification(`${filteredMatches.length} partidos de ${leagueName} encontrados`, 'success');
        }

        function showAllLeagues() {
            const leagues = new Set();
            allMatches.forEach(match => {
                const league = match.league || match.competition || match.tournament || match.event || match.category || 'Sin Liga';
                leagues.add(league);
            });
            
            const leaguesList = Array.from(leagues).sort();
            const leaguesText = leaguesList.join('\n• ');
            
            // Mostrar información de MLS
            let mlsInfo = '';
            if (mlsTeams && mlsTeams.length > 0) {
                mlsInfo = `\n\n⚽ Equipos MLS cargados (${mlsTeams.length}):\n• ${mlsTeams.map(t => t.name).join('\n• ')}`;
            }
            
            alert(`📊 Ligas disponibles (${leagues.size}):\n\n• ${leaguesText}${mlsInfo}`);
            
            // También mostrar en consola para más detalles
            console.log('🏆 Ligas disponibles:', leaguesList);
            console.log('⚽ Equipos MLS:', mlsTeams);
            
            // Contar partidos por liga
            const leagueCounts = {};
            allMatches.forEach(match => {
                const league = match.league || match.competition || match.tournament || match.event || match.category || 'Sin Liga';
                leagueCounts[league] = (leagueCounts[league] || 0) + 1;
            });
            
            console.log('📈 Partidos por liga:', leagueCounts);
            
            // Mostrar partidos de MLS
            const mlsMatches = allMatches.filter(match => isMLSMatch(match));
            console.log('⚽ Partidos de MLS encontrados:', mlsMatches.length);
            mlsMatches.forEach(match => {
                console.log(`  - ${match.teams ? JSON.stringify(match.teams) : 'Sin equipos'}`);
            });
        }

        async function showStreams(matchId, matchTitle) {
            const modal = document.getElementById('streamsModal');
            const modalTitle = document.getElementById('modalTitle');
            const streamsList = document.getElementById('streamsList');
            
            modalTitle.textContent = `Streams - ${matchTitle}`;
            streamsList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-secondary);">Cargando streams...</div>';
            
            modal.style.display = 'block';
            
            try {
                const match = allMatches.find(m => m.id === matchId);
                if (!match || !match.sources) {
                    streamsList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-secondary);">No hay streams disponibles</div>';
                    return;
                }
                
                let streamsHTML = '';
                
                for (const source of match.sources) {
                    try {
                        const response = await fetch(`https://streamed.pk/api/stream/${source.source}/${source.id}`);
                        const streams = await response.json();
                        
                        if (streams && streams.length > 0) {
                            streams.forEach(stream => {
                                streamsHTML += `
                                    <div class="stream-item">
                                        <div class="stream-info">
                                            <span class="stream-quality">${stream.hd ? 'HD' : 'SD'}</span>
                                            <span class="stream-source">${stream.language || source.source}</span>
                                            <span style="color: var(--text-muted); font-size: 0.75rem;">#${stream.streamNo}</span>
                                        </div>
                                        <div class="stream-actions">
                                            <button class="stream-btn btn-embed" onclick="openStream('${stream.embedUrl}')">
                                                📺 Embed
                                            </button>
                                            <button class="stream-btn btn-copy" onclick="copyStreamUrl('${stream.embedUrl}')">
                                                📋 Copiar
                                            </button>
                                        </div>
                                    </div>
                                `;
                            });
                        }
                    } catch (error) {
                        console.error(`Error loading stream for ${source.source}:`, error);
                        streamsHTML += `
                            <div class="stream-item">
                                <div class="stream-info">
                                    <span class="stream-source">${source.source}</span>
                                </div>
                                <span style="color: var(--error-color); font-size: 0.875rem;">Error</span>
                            </div>
                        `;
                    }
                }
                
                if (streamsHTML) {
                    streamsList.innerHTML = streamsHTML;
                } else {
                    streamsList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-secondary);">No hay streams disponibles</div>';
                }
                
            } catch (error) {
                console.error('Error loading streams:', error);
                streamsList.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--error-color);">Error al cargar streams</div>';
            }
        }

        function closeModal() {
            document.getElementById('streamsModal').style.display = 'none';
        }

        function openStream(url) {
            if (!url || url === 'undefined') {
                showNotification('URL de stream no válida', 'error');
                return;
            }
            openStreamOverlay(url, 'Stream');
        }

        function openStreamOverlay(url, title = 'Stream') {
            if (!url || url === 'undefined') {
                showNotification('URL de stream no válida', 'error');
                return;
            }
            
            const overlay = document.getElementById('streamOverlay');
            const iframe = document.getElementById('streamIframe');
            
            if (!overlay || !iframe) {
                return;
            }
            
            // Configurar el overlay
            iframe.src = url;
            
            // Mostrar el overlay
            overlay.style.display = 'block';
            
            // Bloquear scroll del body
            document.body.style.overflow = 'hidden';
            
            // Simular clic en el centro después de que cargue el iframe
            iframe.onload = function() {
                setTimeout(() => {
                    simulateCenterClick(iframe);
                }, 2000);
            };
            
            // También intentar clic después de un tiempo adicional
            setTimeout(() => {
                if (iframe.src && iframe.src !== 'about:blank') {
                    simulateCenterClick(iframe);
                }
            }, 3000);
            
            // Agregar listener para errores del iframe
            iframe.onerror = function() {
                // Error silencioso
            };
        }
        
        function createProxyUrl(originalUrl) {
            try {
                // Lista de proxies disponibles
                const proxies = [
                    {
                        name: 'CorsProxy.io',
                        url: `https://corsproxy.io/?${encodeURIComponent(originalUrl)}`
                    },
                    {
                        name: 'CodeTabs',
                        url: `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(originalUrl)}`
                    },
                    {
                        name: 'AllOrigins',
                        url: `https://api.allorigins.win/raw?url=${encodeURIComponent(originalUrl)}`
                    },
                    {
                        name: 'ThingProxy',
                        url: `https://thingproxy.freeboard.io/fetch/${originalUrl}`
                    }
                ];
                
                // Por ahora usar el primer proxy (CorsProxy.io)
                const selectedProxy = proxies[0];
                addDebugLog(`🌐 Usando proxy ${selectedProxy.name}`);
                return selectedProxy.url;
                
            } catch (error) {
                addDebugLog(`⚠️ Error al crear URL del proxy: ${error.message}`);
                return originalUrl; // Fallback a URL original
            }
        }


        
        function simulateCenterClick(iframe) {
            try {
                const rect = iframe.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                // Intentar acceder al contenido del iframe
                try {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    const playButton = iframeDoc.querySelector('.play-wrapper');
                    
                    if (playButton) {
                        playButton.focus();
                        playButton.click();
                        return;
                    }
                } catch (e) {
                    // Ignorar errores de cross-origin
                }
                
                // Clic en el centro del iframe
                const clickEvent = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true,
                    clientX: centerX,
                    clientY: centerY,
                    button: 0,
                    buttons: 1
                });
                
                iframe.dispatchEvent(clickEvent);
                
                // Clic en elemento encontrado en las coordenadas
                const elementAtPoint = document.elementFromPoint(centerX, centerY);
                if (elementAtPoint) {
                    elementAtPoint.dispatchEvent(clickEvent);
                }
                
            } catch (error) {
                // Error silencioso
            }
        }

        function closeStreamOverlay() {
            const overlay = document.getElementById('streamOverlay');
            const iframe = document.getElementById('streamIframe');
            
            // Ocultar el overlay
            overlay.style.display = 'none';
            
            // Limpiar el iframe
            iframe.src = '';
            
            // Restaurar scroll del body
            document.body.style.overflow = 'auto';
            
            console.log('🔒 Cerrando stream overlay');
        }

        // Event listener para cerrar overlay con Escape y botón atrás de Android
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' || event.key === 'Backspace' || event.keyCode === 4) {
                const overlay = document.getElementById('streamOverlay');
                if (overlay && overlay.style.display === 'block') {
                    closeStreamOverlay();
                }
            }
        });
        
        // Listener específico para el botón atrás de Android
        window.addEventListener('popstate', function(event) {
            const overlay = document.getElementById('streamOverlay');
            if (overlay && overlay.style.display === 'block') {
                closeStreamOverlay();
            }
        });
        
        // Listener adicional para Android - detectar cuando el iframe pierde foco
        window.addEventListener('blur', function(event) {
            const overlay = document.getElementById('streamOverlay');
            if (overlay && overlay.style.display === 'block') {
                setTimeout(() => {
                    closeStreamOverlay();
                }, 100);
            }
        });
        
        // Listener para beforeunload (útil en Android)
        window.addEventListener('beforeunload', function(event) {
            const overlay = document.getElementById('streamOverlay');
            if (overlay && overlay.style.display === 'block') {
                closeStreamOverlay();
            }
        });
        
        // Listener específico para el botón atrás de Android WebView
        document.addEventListener('visibilitychange', function() {
            const overlay = document.getElementById('streamOverlay');
            if (overlay && overlay.style.display === 'block' && document.hidden) {
                closeStreamOverlay();
            }
        });



        // Protección global contra limpieza de consola
        (function protectConsole() {
            const originalConsoleClear = console.clear;
            const originalConsoleLog = console.log;
            const originalConsoleWarn = console.warn;
            const originalConsoleError = console.error;
            
            // Interceptar console.clear
            console.clear = function() {
                originalConsoleLog('🚫 Console.clear() bloqueado - min.js de qzzzzzzzzzqq.com detectado');
                return false;
            };
            
            // Interceptar console.log para detectar intentos de limpieza
            console.log = function(...args) {
                const message = args.join(' ');
                if (message.includes('cleared') || message.includes('console.clear') || message.includes('qzzzzzzzzzqq.com')) {
                    originalConsoleLog('🚫 Intento de limpieza de consola detectado y bloqueado');
                    return;
                }
                originalConsoleLog.apply(console, args);
            };
            
            // Interceptar console.warn
            console.warn = function(...args) {
                const message = args.join(' ');
                if (message.includes('cleared') || message.includes('console.clear')) {
                    originalConsoleLog('🚫 Console.warn con limpieza bloqueado');
                    return;
                }
                originalConsoleWarn.apply(console, args);
            };
            
            // Interceptar console.error
            console.error = function(...args) {
                const message = args.join(' ');
                if (message.includes('cleared') || message.includes('console.clear')) {
                    originalConsoleLog('🚫 Console.error con limpieza bloqueado');
                    return;
                }
                originalConsoleError.apply(console, args);
            };
            
            // Proteger contra otros métodos de limpieza
            if (typeof window !== 'undefined') {
                const originalEval = window.eval;
                window.eval = function(code) {
                    if (typeof code === 'string' && (code.includes('console.clear') || code.includes('qzzzzzzzzzqq.com'))) {
                        originalConsoleLog('🚫 Eval con console.clear bloqueado');
                        return;
                    }
                    return originalEval.apply(this, arguments);
                };
                
                // Proteger contra Function constructor
                const originalFunction = window.Function;
                window.Function = function(...args) {
                    const code = args.join('');
                    if (code.includes('console.clear') || code.includes('qzzzzzzzzzqq.com')) {
                        originalConsoleLog('🚫 Function constructor con console.clear bloqueado');
                        return function() {};
                    }
                    return originalFunction.apply(this, arguments);
                };
            }
            
            originalConsoleLog('🛡️ Protección de consola activada - bloqueando min.js de qzzzzzzzzzqq.com');
        })();

        function copyStreamUrl(url) {
            if (!url || url === 'undefined') {
                showNotification('URL de stream no válida', 'error');
                return;
            }
            
            navigator.clipboard.writeText(url).then(() => {
                showNotification('URL copiada al portapapeles', 'success');
            }).catch(err => {
                console.error('Error copying URL:', err);
                showNotification('Error al copiar URL', 'error');
            });
        }

        async function openBestStream(matchId, matchTitle) {
            try {
                console.log('🎯 Abriendo mejor stream para:', matchTitle);
                
                const match = allMatches.find(m => m.id === matchId);
                console.log('🔍 Match encontrado:', match);
                console.log('🔍 Sources del match:', match?.sources);
                
                if (!match || !match.sources) {
                    showNotification('No hay streams disponibles', 'error');
                    return;
                }
                
                let bestStream = null;
                let maxViewers = 0;
                let spanishStream = null;
                let allStreams = [];
                
                // Buscar el stream con más espectadores, priorizando español
                for (const source of match.sources) {
                    try {
                        const response = await fetch(`https://streamed.pk/api/stream/${source.source}/${source.id}`);
                        const streams = await response.json();
                        
                        if (streams && streams.length > 0) {
                            streams.forEach(stream => {
                                allStreams.push(stream);
                                
                                // Priorizar streams en español
                                const language = (stream.language || '').toLowerCase();
                                const embedUrl = (stream.embedUrl || '').toLowerCase();
                                const isSpanish = language === 'spanish' || embedUrl.includes('spanish');
                                
                                console.log(`🔍 Stream ${stream.streamNo}: language="${language}", embedUrl="${embedUrl}", isSpanish=${isSpanish}`);
                                
                                if (isSpanish && !spanishStream) {
                                    spanishStream = stream;
                                    console.log('✅ Encontrado stream en español:', stream);
                                }
                                
                                // Buscar el stream con más espectadores
                                if (stream.viewers && stream.viewers > maxViewers) {
                                    maxViewers = stream.viewers;
                                    bestStream = stream;
                                }
                            });
                        }
                    } catch (error) {
                        console.error(`Error loading stream for ${source.source}:`, error);
                    }
                }
                
                console.log(`📊 Total streams encontrados: ${allStreams.length}`);
                console.log(`🇪🇸 Stream en español encontrado:`, spanishStream);
                console.log(`👥 Stream con más espectadores:`, bestStream);
                
                // Prioridad: 1) Español, 2) Stream con espectadores, 3) Cualquier stream disponible
                let finalStream = spanishStream;
                if (!finalStream && bestStream && bestStream.viewers > 0) {
                    finalStream = bestStream;
                }
                if (!finalStream) {
                    // Usar cualquier stream disponible (el primero que encuentre)
                    finalStream = allStreams[0] || bestStream;
                }
                
                if (finalStream && finalStream.embedUrl) {
                    console.log('✅ Abriendo stream:', finalStream.embedUrl);
                    openStreamOverlay(finalStream.embedUrl, matchTitle);
                } else {
                    showNotification('No se encontró un stream válido', 'error');
                }
                
            } catch (error) {
                console.error('Error opening best stream:', error);
                showNotification('Error al abrir stream', 'error');
            }
        }

        function showMatchDetails(matchId) {
            const match = allMatches.find(m => m.id === matchId);
            if (match) {
                const details = JSON.stringify(match, null, 2);
                alert(`Detalles del partido:\n\n${details}`);
            }
        }

        // Close modal when clicking outside
        document.getElementById('streamsModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });

        // Función para cargar partidos SOLO de Champions League desde ESPN API
        async function loadChampionsLeagueMatches() {
            try {
                console.log('🔍 Cargando partidos SOLO de Champions League desde ESPN API...');
                
                // Generar fechas dinámicas (hoy y próximos 7 días)
                const fechas = [];
                const hoy = new Date();
                for (let i = 0; i < 7; i++) {
                    const fecha = new Date(hoy);
                    fecha.setDate(hoy.getDate() + i);
                    const fechaStr = fecha.toISOString().split('T')[0].replace(/-/g, '');
                    fechas.push(fechaStr);
                }
                
                let championsMatches = [];
                
                for (const fecha of fechas) {
                    try {
                        const response = await fetch(`https://site.api.espn.com/apis/site/v2/sports/soccer/uefa.champions/scoreboard?dates=${fecha}&limit=50`);
                        if (response.ok) {
                            const data = await response.json();
                            console.log(`🔍 Datos de ESPN para ${fecha}:`, {count: (data.events||[]).length});
                            if (data.events && Array.isArray(data.events)) {
                                championsMatches = championsMatches.concat(data.events);
                            }
                        } else {
                            console.log(`⚠️ Error HTTP ${response.status} para ${fecha}`);
                        }
                    } catch (error) {
                        console.log(`⚠️ Error cargando fecha ${fecha}:`, error.message);
                    }
                }
                
                console.log(`🏆 Total de partidos SOLO de Champions League encontrados (ESPN): ${championsMatches.length}`);
                
                // Crear set de equipos a partir del scoreboard (no standings para evitar ruido si no hay jornada)
                const championsTeams = new Set();
                championsMatches.forEach(match => {
                    if (match && match.name) {
                        const parts = match.name.split(' vs ');
                        parts.forEach(t => championsTeams.add((t||'').trim().toLowerCase()));
                    }
                });
                console.log('🏆 Equipos de Champions (ESPN scoreboard):', championsTeams.size);
                
                // Filtrar partidos de Streamed: criterios estrictos
                const streamedChampionsMatches = allMatches.filter(match => {
                    if (!match || !match.title) return false;
                    const title = match.title.toLowerCase();
                    const isEuropa = title.includes('europa league');
                    const isConference = title.includes('conference league');
                    const hasChampionsLabel = title.includes('champions league') || title.includes('uefa champions');
                    
                    if (isEuropa || isConference) return false;
                    
                    // Si ESPN tiene 0 eventos para este período, no intentar inferir: retornar solo si etiqueta explícita
                    if (championsMatches.length === 0) {
                        return hasChampionsLabel;
                    }
                    
                    // Con ESPN: permitir etiqueta explícita, o cruce por equipos del scoreboard
                    if (hasChampionsLabel) return true;
                    
                    // Extraer equipos del título y validar ambos en set de ESPN
                    const parsed = extractTeamsFromTitle(match.title) || [];
                    if (parsed.length === 2) {
                        const a = parsed[0].toLowerCase();
                        const b = parsed[1].toLowerCase();
                        const inA = Array.from(championsTeams).some(ct => a.includes(ct) || ct.includes(a));
                        const inB = Array.from(championsTeams).some(ct => b.includes(ct) || ct.includes(b));
                        if (inA && inB) return true;
                    }
                    return false;
                });
                
                console.log(`⚽ Partidos SOLO de Champions League identificados en Streamed (estricto): ${streamedChampionsMatches.length}`);
                streamedChampionsMatches.forEach(match => console.log(`  - ${match.title}`));
                
                return {
                    championsMatches,
                    streamedChampionsMatches,
                    championsTeams: Array.from(championsTeams)
                };
                
            } catch (error) {
                console.error('Error cargando partidos de Champions League:', error);
                return { championsMatches: [], streamedChampionsMatches: [], championsTeams: [] };
            }
        }

        // Función para filtrar por Champions League
        function filterByChampionsLeague() {
            // Usar clasificación general por título para determinar competición y limitar a HOY
            const championsToday = allMatches.filter(m => {
                const comp = computeNormalizedCompetition(m);
                return comp === 'Champions League' && isTodayLocal(Number(m.date));
            });

            currentMatches = championsToday;
            displayMatches(currentMatches);
        }

        // Función de debug para Champions League
        function debugChampionsLeague() {
            console.log('🔍 DEBUG: Iniciando debug de Champions League...');
            console.log('🔍 Total de partidos cargados:', allMatches.length);
            
            // Mostrar todos los partidos que contengan "brugge" o "rangers"
            const partidosRelevantes = allMatches.filter(match => {
                if (!match.title) return false;
                const title = match.title.toLowerCase();
                return title.includes('brugge') || title.includes('rangers') || title.includes('benfica') || title.includes('fenerbahce');
            });
            
            // Buscar específicamente "Club Brugge vs Rangers"
            const bruggeRangers = allMatches.filter(match => {
                if (!match.title) return false;
                const title = match.title.toLowerCase();
                return title.includes('club brugge') && title.includes('rangers');
            });
            
            console.log('🔍 Partido específico Club Brugge vs Rangers encontrado:', bruggeRangers.length);
            bruggeRangers.forEach(match => {
                console.log(`  - ${match.title}`);
            });
            
            console.log('🔍 Partidos relevantes encontrados:', partidosRelevantes.length);
            partidosRelevantes.forEach(match => {
                console.log(`  - ${match.title}`);
            });
            
            // Ejecutar la función normal de Champions League
            loadChampionsLeagueMatches().then(result => {
                console.log('🔍 DEBUG: Resultado de loadChampionsLeagueMatches:', result);
            });
        }

        // Ponderaciones
        const COMPETITION_WEIGHTS = {
            'Champions League': 1000,
            'Europa League': 700,
            'Conference League': 500,
            'Premier League': 650,
            'LaLiga': 600,
            'Serie A': 550,
            'Bundesliga': 500,
            'Ligue 1': 450,
            'FA Cup': 400,
            'Carabao Cup': 350,
            'Fútbol': 100
        };

        const BIG_TEAMS = [
            'real madrid','barcelona','atlético','atletico','sevilla','valencia','villarreal',
            'manchester city','manchester united','chelsea','arsenal','liverpool','tottenham',
            'bayern','borussia dortmund','psg','paris saint-germain','marseille','lyon',
            'juventus','inter','milan','ac milan','napoli','roma'
        ];

        function computeMatchScore(match) {
            let score = 0;
            const comp = computeNormalizedCompetition(match) || 'Fútbol';
            score += COMPETITION_WEIGHTS[comp] || 0;
            
            // Equipos grandes
            const title = (match.title || '').toLowerCase();
            BIG_TEAMS.forEach(t => { if (title.includes(t)) score += 120; });
            
            // En vivo/scheduled como desempate
            const st = getMatchStatus(match);
            if (st === 'live') score += 80; else if (st === 'scheduled') score += 40;
            
            // Número de fuentes
            if (Array.isArray(match.sources)) score += match.sources.length * 10;
            
            return score;
        }

        function getPopularMatches(matches, limit = 5) {
            if (!matches || matches.length === 0) return [];
            
            const ranked = matches.map(m => ({ m, s: computeMatchScore(m) }))
                                  .sort((a,b) => b.s - a.s)
                                  .slice(0, limit)
                                  .map(x => x.m);
            return ranked;
        }

        function getCategory(match) {
            function pickString(val) {
                if (!val) return '';
                if (typeof val === 'string') return val;
                if (typeof val === 'number') return String(val);
                if (Array.isArray(val)) {
                    // tomar primer string útil del array
                    for (const item of val) {
                        const s = pickString(item);
                        if (s) return s;
                    }
                    return '';
                }
                if (typeof val === 'object') {
                    // campos comunes: name, title, displayName, caption
                    const keys = ['name','title','displayName','caption','competition','league'];
                    for (const k of keys) {
                        if (val[k]) {
                            const s = pickString(val[k]);
                            if (s) return s;
                        }
                    }
                }
                return '';
            }

            const candidates = [
                match.competition,
                match.tournament,
                match.event,
                match.category,
                match.league,
                match.sport,
                match.metadata && match.metadata.competition,
                match.details && match.details.league
            ];

            let raw = '';
            for (const c of candidates) {
                raw = pickString(c);
                if (raw && raw.trim().length > 0) break;
            }
            if (!raw) return '';

            let val = raw.toString().trim();
            const lower = val.toLowerCase();

            // Omitir términos genéricos
            const generics = ['football','soccer','deportes','sports','futbol','fútbol'];
            if (generics.includes(lower)) return '';

            // Mapear competiciones comunes a etiquetas estándar/español
            const mappings = [
                { k: 'uefa champions', v: 'Champions League' },
                { k: 'champions league', v: 'Champions League' },
                { k: 'uefa europa', v: 'Europa League' },
                { k: 'europa league', v: 'Europa League' },
                { k: 'conference league', v: 'Conference League' },
                { k: 'premier league', v: 'Premier League' },
                { k: 'la liga', v: 'LaLiga' },
                { k: 'serie a', v: 'Serie A' },
                { k: 'bundesliga', v: 'Bundesliga' },
                { k: 'ligue 1', v: 'Ligue 1' },
                { k: 'carabao cup', v: 'Carabao Cup' },
                { k: 'efl cup', v: 'Carabao Cup' },
                { k: 'fa cup', v: 'FA Cup' },
                { k: 'coppa italia', v: 'Coppa Italia' },
                { k: 'copa del rey', v: 'Copa del Rey' },
                { k: 'dfb-pokal', v: 'DFB-Pokal' }
            ];
            for (const m of mappings) {
                if (lower.includes(m.k)) return m.v;
            }

            // Capitalización limpia
            val = val.replace(/\s+/g, ' ').trim();
            val = val.split(' ').map(w => w.length > 2 ? w[0].toUpperCase() + w.slice(1) : w.toLowerCase()).join(' ');
            return val;
        }

        // Normalizar títulos a español para coincidencias (equipos/competiciones)
        function normalizeSpanishTitle(title) {
            if (!title || typeof title !== 'string') return '';
            let t = title;
            // Mapeos comunes de equipos/competiciones a español
            const replacements = [
                // Competición
                { from: /uefa\s*champions\s*league/gi, to: 'liga de campeones' },
                { from: /champions\s*league/gi, to: 'liga de campeones' },
                { from: /uefa\s*europa\s*league/gi, to: 'liga europa' },
                { from: /europa\s*league/gi, to: 'liga europa' },
                { from: /conference\s*league/gi, to: 'conference league' },
                // Equipos
                { from: /red\s*star\s*belgrade/gi, to: 'estrella roja' },
                { from: /crvena\s*zvezda/gi, to: 'estrella roja' },
                { from: /bodo\/?glimt/gi, to: 'bodø\/glimt' }
            ];
            replacements.forEach(r => { t = t.replace(r.from, r.to); });
            return t;
        }

        function getCompetitionFromTitle(title) {
            if (!title || typeof title !== 'string') return '';
            // Asegurar coincidencias en español primero
            const normalized = normalizeSpanishTitle(title);
            const t = normalized.trim();
            // Si viene con prefijo "Competición: TeamA vs TeamB"
            const idx = t.indexOf(':');
            if (idx > 0) {
                const prefix = t.slice(0, idx).toLowerCase();
                if (prefix.includes('liga de campeones')) return 'Champions League';
                if (prefix.includes('liga europa')) return 'Europa League';
                if (prefix.includes('conference league')) return 'Conference League';
                if (prefix.includes('premier league')) return 'Premier League';
                if (prefix.includes('la liga')) return 'LaLiga';
                if (prefix.includes('serie a')) return 'Serie A';
                if (prefix.includes('bundesliga')) return 'Bundesliga';
                if (prefix.includes('ligue 1')) return 'Ligue 1';
                if (prefix.includes('carabao cup') || prefix.includes('efl cup')) return 'Carabao Cup';
                if (prefix.includes('fa cup')) return 'FA Cup';
            }
            // Detección dentro del título completo
            const lt = t.toLowerCase();
            if (lt.includes('liga de campeones')) return 'Champions League';
            if (lt.includes('liga europa')) return 'Europa League';
            if (lt.includes('conference league')) return 'Conference League';
            if (lt.includes('premier league')) return 'Premier League';
            if (lt.includes('la liga')) return 'LaLiga';
            if (lt.includes('serie a')) return 'Serie A';
            if (lt.includes('bundesliga')) return 'Bundesliga';
            if (lt.includes('ligue 1')) return 'Ligue 1';
            if (lt.includes('carabao cup') || lt.includes('efl cup')) return 'Carabao Cup';
            if (lt.includes('fa cup')) return 'FA Cup';
            return '';
        }

        // Cache de competiciones normalizadas por partido
        const competitionCache = new Map();
        // Overrides provenientes del diario externo (ftvhd)
        const competitionOverride = new Map();

        async function fetchDiaryToday() {
            try {
                const today = new Date().toISOString().slice(0,10); // yyyy-mm-dd
                const res = await fetch('https://ftvhd.com/diaries.json');
                const json = await res.json();
                const items = Array.isArray(json?.data) ? json.data : [];
                // Quedarse con eventos de hoy
                const todayEvents = items.filter(it => it?.attributes?.date_diary === today);
                return todayEvents.map(it => {
                    const desc = it.attributes?.diary_description || '';
                    const hour = it.attributes?.diary_hour || '';
                    return { description: desc, hour, competition: getCompetitionFromTitle(desc) };
                });
            } catch (e) {
                console.log('ftvhd diary error:', e.message);
                return [];
            }
        }

        function teamsFromString(title) {
            const parsed = extractTeamsFromTitle(title || '') || [];
            if (parsed.length === 2) {
                return [ normalizeTeamSpanish(limpiarNombreEquipo(parsed[0])).toLowerCase(),
                         normalizeTeamSpanish(limpiarNombreEquipo(parsed[1])).toLowerCase() ];
            }
            return [];
        }

        function teamsFromStringRaw(title) {
            const parsed = extractTeamsFromTitle(title || '') || [];
            if (parsed.length === 2) {
                return [ (parsed[0] || '').trim().toLowerCase(), (parsed[1] || '').trim().toLowerCase() ];
            }
            return [];
        }

        function normalizeForMatch(name) {
            if (!name) return '';
            // a minúsculas, quitar acentos/diacríticos, quitar símbolos y espacios extra
            const s = name.toLowerCase()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .replace(/[^a-z0-9\/\s]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            // alias básicos
            const aliases = [
                { r: /crvena zvezda|red star belgrade|estrella roja/g, to: 'estrella roja' },
                { r: /bod[oø] \/? glimt|bodo \/? glimt|bodo glimt/g, to: 'bodo glimt' },
                { r: /paphos/g, to: 'pafos' }
            ];
            let out = s;
            aliases.forEach(a => { out = out.replace(a.r, a.to); });
            return out;
        }

        function parseDiaryHourToTodayTime(hhmmss) {
            try {
                const [hh, mm, ss] = (hhmmss || '00:00:00').split(':').map(x => parseInt(x, 10) || 0);
                const now = new Date();
                const d = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hh, mm, ss, 0);
                return d.getTime();
            } catch (_) { return 0; }
        }

        function diaryAssignCompetitionsForToday(matches, diaryEvents) {
            if (!Array.isArray(matches) || matches.length === 0 || !Array.isArray(diaryEvents)) return;
            // Construir lista de eventos con pares de equipos (tal como vienen)
            const diaryParsed = diaryEvents.map(ev => {
                const t = ev.description || '';
                const [aRaw,bRaw] = teamsFromStringRaw(t);
                const a = normalizeForMatch(aRaw);
                const b = normalizeForMatch(bRaw);
                const ts = parseDiaryHourToTodayTime(ev.hour);
                return { a, b, comp: ev.competition, ts };
            }).filter(x => x.a && x.b && x.comp);
 
            matches.forEach(m => {
                const isToday = isTodayLocal(Number(m.date));
                if (!isToday) return;
                const [maRaw, mbRaw] = teamsFromStringRaw(m.title || '');
                const ma = normalizeForMatch(maRaw);
                const mb = normalizeForMatch(mbRaw);
                if (!ma || !mb) return;
                const ms = Number(m.date);
                // Coincidencia si ambos equipos aparecen (contiene/incluye) en alguna entrada del diario (sin normalización)
                const hit = diaryParsed.find(ev => {
                    const aMatch = ma.includes(ev.a) || ev.a.includes(ma);
                    const bMatch = mb.includes(ev.b) || ev.b.includes(mb);
                    const aMatchAlt = ma.includes(ev.b) || ev.b.includes(ma);
                    const bMatchAlt = mb.includes(ev.a) || ev.a.includes(mb);
                    const teamOk = (aMatch && bMatch) || (aMatchAlt && bMatchAlt);
                    if (!teamOk) return false;
                    // tolerancia horaria ±90 minutos si el diario trae hora
                    if (ev.ts && ms) {
                        const diffMin = Math.abs(ms - ev.ts) / 60000;
                        return diffMin <= 90;
                    }
                    return true;
                });
                if (hit && hit.comp) {
                    const key = m.id || m.title || JSON.stringify(m).slice(0,100);
                    competitionOverride.set(key, hit.comp);
                }
            });
        }

        function computeNormalizedCompetition(match) {
            if (!match) return '';
            const key = match.id || match.title || JSON.stringify(match).slice(0,100);
            // Primero, si hay override del diario, usarlo
            if (competitionOverride.has(key)) return competitionOverride.get(key) || '';
            if (competitionCache.has(key)) return competitionCache.get(key) || '';
            
            // 1) Intentar desde título (normalizado a español para coincidencias)
            const derivedTitle = normalizeSpanishTitle(match.title || '');
            let comp = getCompetitionFromTitle(derivedTitle);
            // 2) Si no, intentar categoría no genérica
            if (!comp) comp = getCategory(match);
            
            competitionCache.set(key, comp || '');
            return comp || '';
        }

        function getDisplayCategory(match) {
            console.log('🔍 getDisplayCategory llamado con:', match.title);
            
            // 1. Extraer categoría específica del título del partido
            if (match.title) {
                // Extraer categoría (lo que está antes de ":")
                const categoryMatch = match.title.match(/^([^:]+):\s*(.+)$/);
                console.log('🔍 categoryMatch:', categoryMatch);
                
                if (categoryMatch) {
                    let category = categoryMatch[1].trim();
                    console.log('🔍 Categoría extraída del título:', category);
                    
                    // Limpiar categorías comunes
                    if (category.includes('UEFA Champions League')) {
                        console.log('✅ Retornando: Champions League');
                        return 'Champions League';
                    } else if (category.includes('UEFA Europa League')) {
                        console.log('✅ Retornando: Europa League');
                        return 'Europa League';
                    } else if (category.includes('Premier League')) {
                        console.log('✅ Retornando: Premier League');
                        return 'Premier League';
                    } else if (category.includes('La Liga')) {
                        console.log('✅ Retornando: La Liga');
                        return 'La Liga';
                    } else if (category.includes('Serie A')) {
                        console.log('✅ Retornando: Serie A');
                        return 'Serie A';
                    } else if (category.includes('Bundesliga')) {
                        console.log('✅ Retornando: Bundesliga');
                        return 'Bundesliga';
                    } else if (category.includes('Ligue 1')) {
                        console.log('✅ Retornando: Ligue 1');
                        return 'Ligue 1';
                    } else if (category.includes('DFB Pokal')) {
                        console.log('✅ Retornando: DFB Pokal');
                        return 'DFB Pokal';
                    } else if (category.includes('Copa Argentina')) {
                        console.log('✅ Retornando: Copa Argentina');
                        return 'Copa Argentina';
                    } else if (category.includes('Serie B')) {
                        console.log('✅ Retornando: Serie B');
                        return 'Serie B';
                    } else if (category.includes('CONCACAF')) {
                        console.log('✅ Retornando: CONCACAF');
                        return 'CONCACAF';
                    } else if (category.includes('USL League')) {
                        console.log('✅ Retornando: USL League');
                        return 'USL League';
                    } else if (category.includes('League Cup')) {
                        console.log('✅ Retornando: League Cup');
                        return 'League Cup';
                    }
                    
                    // Si no coincide con ninguna categoría conocida, devolver la original
                    console.log('✅ Retornando categoría original:', category);
                    return category;
                }
            }
            
            // 2. Buscar en otros campos del objeto match
            console.log('🔍 Buscando en otros campos del match:', match);
            
            // Buscar en category, competition, tournament, league, etc.
            const possibleFields = ['category', 'competition', 'tournament', 'league', 'event', 'sport'];
            for (const field of possibleFields) {
                if (match[field]) {
                    console.log(`🔍 Encontrado en ${field}:`, match[field]);
                    let category = String(match[field]).trim();
                    
                    // Limpiar categorías comunes
                    if (category.includes('UEFA Champions League') || category.includes('Champions League')) {
                        console.log('✅ Retornando: Champions League');
                        return 'Champions League';
                    } else if (category.includes('UEFA Europa League') || category.includes('Europa League')) {
                        console.log('✅ Retornando: Europa League');
                        return 'Europa League';
                    } else if (category.includes('Premier League')) {
                        console.log('✅ Retornando: Premier League');
                        return 'Premier League';
                    } else if (category.includes('La Liga')) {
                        console.log('✅ Retornando: La Liga');
                        return 'La Liga';
                    } else if (category.includes('Serie A')) {
                        console.log('✅ Retornando: Serie A');
                        return 'Serie A';
                    } else if (category.includes('Bundesliga')) {
                        console.log('✅ Retornando: Bundesliga');
                        return 'Bundesliga';
                    } else if (category.includes('Ligue 1')) {
                        console.log('✅ Retornando: Ligue 1');
                        return 'Ligue 1';
                    } else if (category.includes('DFB Pokal')) {
                        console.log('✅ Retornando: DFB Pokal');
                        return 'DFB Pokal';
                    } else if (category.includes('Copa Argentina')) {
                        console.log('✅ Retornando: Copa Argentina');
                        return 'Copa Argentina';
                    } else if (category.includes('Serie B')) {
                        console.log('✅ Retornando: Serie B');
                        return 'Serie B';
                    } else if (category.includes('CONCACAF')) {
                        console.log('✅ Retornando: CONCACAF');
                        return 'CONCACAF';
                    } else if (category.includes('USL League')) {
                        console.log('✅ Retornando: USL League');
                        return 'USL League';
                    } else if (category.includes('League Cup') || category.includes('Carabao Cup')) {
                        console.log('✅ Retornando: League Cup');
                        return 'League Cup';
                    }
                    
                    // Si no coincide con ninguna categoría conocida, devolver la original
                    console.log('✅ Retornando categoría de campo:', category);
                    
                    // Convertir "football" a "Fútbol"
                    if (category.toLowerCase() === 'football') {
                        return 'Fútbol';
                    }
                    
                    return category;
                }
            }
            
            // 3. Preferir competición normalizada del sistema como fallback
            const comp = computeNormalizedCompetition(match);
            console.log('🔍 computeNormalizedCompetition result:', comp);
            if (comp) return comp;
            
            // 4. Detectar categoría basada en equipos conocidos
            if (match.title) {
                const title = match.title.toLowerCase();
                console.log('🔍 Detectando categoría por equipos en:', title);
                
                // Champions League teams
                if (title.includes('celtic') || title.includes('qarabag') || title.includes('ferencvarosi') || 
                    title.includes('benfica') || title.includes('fenerbahce') || title.includes('sturm graz') ||
                    title.includes('bodo') || title.includes('glimt') || title.includes('pafos') || 
                    title.includes('red star') || title.includes('crvena zvezda')) {
                    console.log('✅ Detectado Champions League por equipos');
                    return 'Champions League';
                }
                
                // Premier League teams
                if (title.includes('chelsea') || title.includes('fulham') || title.includes('manchester united') ||
                    title.includes('burnley') || title.includes('wolves') || title.includes('west ham') ||
                    title.includes('tottenham') || title.includes('bournemouth') || title.includes('sunderland') ||
                    title.includes('brentford') || title.includes('leeds') || title.includes('newcastle') ||
                    title.includes('nottingham') || title.includes('brighton') || title.includes('manchester city') ||
                    title.includes('liverpool') || title.includes('arsenal') || title.includes('aston villa') ||
                    title.includes('crystal palace') || title.includes('everton')) {
                    console.log('✅ Detectado Premier League por equipos');
                    return 'Premier League';
                }
                
                // Europa League teams
                if (title.includes('kups') || title.includes('midtjylland') || title.includes('sigma olomouc') ||
                    title.includes('malmo') || title.includes('samsunspor') || title.includes('panathinaikos') ||
                    title.includes('ludogorets') || title.includes('shkendija') || title.includes('paok') ||
                    title.includes('rijeka') || title.includes('utrecht') || title.includes('zrinjski') ||
                    title.includes('genk') || title.includes('lech poznan') || title.includes('dynamo kyiv') ||
                    title.includes('maccabi') || title.includes('young boys') || title.includes('slovan') ||
                    title.includes('fcsb') || title.includes('aberdeen') || title.includes('braga') ||
                    title.includes('lincoln red imps')) {
                    console.log('✅ Detectado Europa League por equipos');
                    return 'Europa League';
                }
                
                // DFB Pokal teams
                if (title.includes('bayern') || title.includes('stuttgart') || title.includes('eintracht')) {
                    console.log('✅ Detectado DFB Pokal por equipos');
                    return 'DFB Pokal';
                }
                
                // Copa Argentina teams
                if (title.includes('river plate') || title.includes('union santa fe')) {
                    console.log('✅ Detectado Copa Argentina por equipos');
                    return 'Copa Argentina';
                }
                
                // Serie B teams
                if (title.includes('remo') || title.includes('criciuma')) {
                    console.log('✅ Detectado Serie B por equipos');
                    return 'Serie B';
                }
                
                // CONCACAF teams
                if (title.includes('moca') || title.includes('mount pleasant')) {
                    console.log('✅ Detectado CONCACAF por equipos');
                    return 'CONCACAF';
                }
                
                // USL League teams
                if (title.includes('forward madison') || title.includes('texoma') || title.includes('knoxville') ||
                    title.includes('naples')) {
                    console.log('✅ Detectado USL League por equipos');
                    return 'USL League';
                }
                
                // African teams
                if (title.includes('madagascar') || title.includes('sudan') || title.includes('morocco') ||
                    title.includes('senegal') || title.includes('polokwane') || title.includes('durban') ||
                    title.includes('richards bay') || title.includes('chippa') || title.includes('stellenbosch') ||
                    title.includes('marumo') || title.includes('orlando pirates') || title.includes('orbit') ||
                    title.includes('ts galaxy') || title.includes('siwelele')) {
                    console.log('✅ Detectado Fútbol Africano por equipos');
                    return 'Fútbol Africano';
                }
                
                // Mexican teams
                if (title.includes('cruz azul') || title.includes('toluca') || title.includes('pachuca') ||
                    title.includes('atlas') || title.includes('guadalajara') || title.includes('monterrey') ||
                    title.includes('queretaro') || title.includes('tigres')) {
                    console.log('✅ Detectado Liga MX por equipos');
                    return 'Liga MX';
                }
                
                // Colombian teams
                if (title.includes('bogota') || title.includes('cucuta') || title.includes('atletico junior') ||
                    title.includes('atletico fc') || title.includes('deportivo pereira') || title.includes('real cundinamarca') ||
                    title.includes('real cartagena') || title.includes('millonarios') || title.includes('cartagines') ||
                    title.includes('independiente') || title.includes('deportivo saprissa') || title.includes('motagua')) {
                    console.log('✅ Detectado Fútbol Colombiano por equipos');
                    return 'Fútbol Colombiano';
                }
                
                // Caribbean teams
                if (title.includes('robinhood') || title.includes('central fc') || title.includes('weymouth wales') ||
                    title.includes('cibao')) {
                    console.log('✅ Detectado Fútbol Caribeño por equipos');
                    return 'Fútbol Caribeño';
                }
            }
            
            // 5. Último fallback
            console.log('❌ Retornando fallback: Fútbol');
            return 'Fútbol';
        }

        async function loadStreamsWithMostViewers() {
            try {
                console.log('🔥 Cargando partidos ordenados por espectadores...');
                
                // Obtener todos los partidos de una vez
                const response = await fetch('https://streamed.pk/api/matches/live');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const allMatches = await response.json();
                
                if (!Array.isArray(allMatches)) {
                    throw new Error('La respuesta no es un array de partidos');
                }
                
                console.log(`📊 Procesando ${allMatches.length} partidos para ordenar por espectadores...`);
                
                // Filtrar solo partidos de fútbol (filtro más estricto)
                const footballMatches = allMatches.filter(match => {
                    const title = match.title?.toLowerCase() || '';
                    const category = match.category?.toLowerCase() || '';
                    
                    // EXCLUIR deportes que NO son fútbol
                    const nonFootballKeywords = [
                        'tennis', 'basketball', 'basket', 'nba', 'baseball', 'mlb', 'hockey', 'nhl',
                        'volleyball', 'volley', 'rugby', 'cricket', 'golf', 'boxing', 'mma', 'ufc',
                        'wrestling', 'wwe', 'aew', 'racing', 'f1', 'formula', 'nascar', 'motogp',
                        'cycling', 'cycling', 'swimming', 'athletics', 'track', 'field', 'olympics',
                        'olympic', 'esports', 'csgo', 'lol', 'league of legends', 'dota', 'valorant',
                        'us open', 'wimbledon', 'australian open', 'french open', 'grand slam',
                        'court', 'set', 'match point', 'serve', 'ace', 'deuce', 'advantage',
                        'grandstand', 'christopher', 'alex', 'minaur', 'oconnell', 'player', 'players',
                        'singles', 'doubles', 'mixed', 'qualifying', 'main draw', 'round', 'final',
                        'semifinal', 'quarterfinal', 'robin', 'group', 'pool', 'bracket'
                    ];
                    
                    // Si contiene palabras de otros deportes, excluirlo
                    if (nonFootballKeywords.some(keyword => title.includes(keyword))) {
                        return false;
                    }
                    
                    // INCLUIR solo si es claramente fútbol
                    const footballKeywords = [
                        'football', 'soccer', 'futbol', 'fútbol', 'liga', 'league', 'champions', 
                        'europa', 'premier', 'bundesliga', 'serie a', 'la liga', 'ligue 1',
                        'copa', 'cup', 'uefa', 'fifa', 'world cup', 'copa del mundo',
                        'euro', 'european', 'qualifiers', 'eliminatorias', 'friendly', 'amistoso',
                        'dfb pokal', 'fa cup', 'carabao cup', 'super cup', 'community shield'
                    ];
                    
                    // Debe tener categoría football O contener palabras clave de fútbol
                    const isFootballByCategory = category === 'football';
                    const isFootballByKeywords = footballKeywords.some(keyword => 
                        title.includes(keyword) || category.includes(keyword)
                    );
                    
                    // Solo incluir partidos que tengan "vs" Y sean claramente de fútbol
                    const hasVs = (title.includes(' vs ') || title.includes(' versus ')) && 
                                 !nonFootballKeywords.some(keyword => title.includes(keyword)) &&
                                 (isFootballByCategory || isFootballByKeywords);
                    
                    // Solo retornar true si es claramente fútbol
                    return isFootballByCategory || (isFootballByKeywords && hasVs);
                });
                
                console.log(`⚽ Partidos de fútbol encontrados: ${footballMatches.length}`);
                
                // Mostrar los primeros 5 partidos filtrados para debug
                if (footballMatches.length > 0) {
                    console.log('⚽ Primeros 5 partidos de fútbol filtrados:');
                    footballMatches.slice(0, 5).forEach((match, index) => {
                        console.log(`  ${index + 1}. ${match.title} (${match.category})`);
                    });
                }
                
                // FILTRAR partidos por rango de tiempo (2 horas desde ahora)
                const now = new Date();
                const twoHoursFromNow = new Date(now.getTime() + (2 * 60 * 60 * 1000)); // +2 horas
                
                const timeFilteredMatches = footballMatches.filter(match => {
                    if (!match.time) return false;
                    
                    const matchTime = new Date(match.time);
                    return matchTime >= now && matchTime <= twoHoursFromNow;
                });
                
                console.log(`⚽ Partidos en las próximas 2 horas: ${timeFilteredMatches.length}`);
                
                // Si no hay partidos en las próximas 2 horas, usar los próximos 10 partidos
                const limitedMatches = timeFilteredMatches.length > 0 ? 
                    timeFilteredMatches.slice(0, 10) : 
                    footballMatches.slice(0, 10);
                
                console.log(`⚽ Procesando ${limitedMatches.length} partidos seleccionados`);
                
                // Array para almacenar todos los streams con sus espectadores
                const allStreams = [];
                
                // Lista de fuentes a consultar (reducida para evitar rate limiting)
                const sources = ['alpha', 'bravo', 'echo', 'hotel'];
                
                // Procesar solo partidos de fútbol limitados
                for (let i = 0; i < limitedMatches.length; i++) {
                    const match = limitedMatches[i];
                    
                    for (let j = 0; j < sources.length; j++) {
                        const source = sources[j];
                        
                        // Agregar delay de 200ms entre peticiones para evitar rate limiting
                        if (j > 0) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                        
                        try {
                            // Usar el ID específico de la fuente si existe, sino usar el ID general
                            let sourceId = match.id;
                            
                            // Si el partido tiene sources, buscar el ID específico para esta fuente
                            if (match.sources && Array.isArray(match.sources)) {
                                const sourceMatch = match.sources.find(s => s.source === source);
                                if (sourceMatch) {
                                    sourceId = sourceMatch.id;
                                }
                            }
                            

                            const streamResponse = await fetch(`https://streamed.pk/api/stream/${source}/${sourceId}`);
                            
                            if (streamResponse.ok) {
                                const streams = await streamResponse.json();
                                
                                if (Array.isArray(streams) && streams.length > 0) {
                                    streams.forEach(stream => {
                                        if (stream.viewers && stream.viewers > 0) {
                                            console.log(`✅ Encontrado ${stream.viewers} espectadores en ${source} para ${match.title}`);
                                            allStreams.push({
                                                ...stream,
                                                matchTitle: match.title,
                                                matchId: match.id,
                                                matchCategory: match.category,
                                                matchPoster: match.poster,
                                                matchTime: match.time, // Agregar tiempo del partido original
                                                teams: match.teams // Agregar estructura teams del partido original
                                            });
                                        }
                                    });
                                }
                            } else {
                                console.log(`❌ Error ${streamResponse.status} en ${source} para ${match.title}`);
                            }
                        } catch (error) {
                            console.log(`❌ Error en ${source} para ${match.title}: ${error.message}`);
                        }
                        
                        // Agregar delay de 100ms entre peticiones para evitar rate limiting
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                // Ordenar por número de espectadores (descendente)
                const sortedStreams = allStreams.sort((a, b) => b.viewers - a.viewers);
                
                console.log(`🔥 Total streams con espectadores encontrados: ${sortedStreams.length}`);
                
                // Mostrar los top 10 streams con más espectadores
                if (sortedStreams.length > 0) {
                    console.log('🔥 Top streams por espectadores:');
                    sortedStreams.slice(0, 10).forEach((stream, index) => {
                        console.log(`  ${index + 1}. ${stream.matchTitle} - ${stream.source} (${stream.viewers} viewers)`);
                    });
                }
                
                // Retornar los partidos únicos de los streams con más espectadores
                const uniqueMatches = [];
                const seenMatchIds = new Set();
                
                for (const stream of sortedStreams) {
                    if (!seenMatchIds.has(stream.matchId)) {
                        seenMatchIds.add(stream.matchId);
                        uniqueMatches.push({
                            id: stream.matchId,
                            title: stream.matchTitle,
                            category: stream.matchCategory,
                            poster: stream.matchPoster,
                            topViewers: stream.viewers,
                            topSource: stream.source,
                            time: stream.matchTime, // Usar tiempo del partido original
                            teams: stream.teams // Agregar estructura teams si existe
                        });
                    }
                }
                
                // Filtrar solo partidos futuros o en vivo (excluir finalizados)
                const currentTime = new Date();
                const futureMatches = uniqueMatches.filter(match => {
                    if (!match.time) return true; // Si no tiene tiempo, incluirlo
                    
                    const matchTime = new Date(match.time);
                    const timeDiff = matchTime - currentTime;
                    const hoursDiff = timeDiff / (1000 * 60 * 60);
                    
                    // Solo incluir partidos que:
                    // - Están en vivo (dentro de las últimas 3 horas)
                    // - Son futuros (en las próximas 24 horas)
                    // - NO están finalizados (más de 3 horas atrás)
                    return hoursDiff >= -3 && hoursDiff <= 24;
                });
                
                // Ordenar por horario (ascendente - más temprano primero)
                const sortedByTime = futureMatches.sort((a, b) => {
                    if (!a.time && !b.time) return 0;
                    if (!a.time) return 1;
                    if (!b.time) return -1;
                    
                    const timeA = new Date(a.time);
                    const timeB = new Date(b.time);
                    return timeA - timeB;
                });
                
                // Contar partidos finalizados para el log
                const finishedMatches = uniqueMatches.filter(match => {
                    if (!match.time) return false;
                    const matchTime = new Date(match.time);
                    const timeDiff = matchTime - currentTime;
                    const hoursDiff = timeDiff / (1000 * 60 * 60);
                    return hoursDiff < -3; // Más de 3 horas atrás
                });
                
                console.log(`🕐 Partidos filtrados: ${uniqueMatches.length} total, ${futureMatches.length} futuros/en vivo, ${finishedMatches.length} finalizados (excluidos)`);
                console.log('🕐 Partidos ordenados por horario:');
                sortedByTime.slice(0, 8).forEach((match, index) => {
                    const timeStr = match.time ? new Date(match.time).toLocaleString() : 'Sin horario';
                    console.log(`  ${index + 1}. ${match.title} - ${timeStr}`);
                });
                
                // FALLBACK: Si no hay suficientes partidos con espectadores, agregar partidos en vivo
                let finalMatches = sortedByTime.slice(0, 8);
                
                // Solo agregar fallback si realmente no hay suficientes partidos con espectadores
                if (finalMatches.length < 4) {
                    console.log(`🔄 Fallback: Solo ${finalMatches.length} partidos con espectadores, agregando partidos en vivo...`);
                    
                    // Obtener partidos en vivo como fallback (SOLO FÚTBOL)
                    // Excluir partidos que ya están en la lista principal
                    const existingTitlesForFallback = new Set(finalMatches.map(m => m.title.toLowerCase().trim()));
                    
                    const liveMatches = allMatches.filter(match => {
                        // Excluir si ya está en la lista principal
                        if (existingTitlesForFallback.has(match.title.toLowerCase().trim())) {
                            return false;
                        }
                        // Filtro estricto de fútbol
                        const title = match.title?.toLowerCase() || '';
                        const category = match.category?.toLowerCase() || '';
                        
                        // Excluir otros deportes
                        const nonFootballKeywords = ['tennis', 'basketball', 'baseball', 'cricket', 'hockey', 'volleyball', 'rugby', 'golf', 'boxing', 'mma', 'ufc', 'wrestling', 'esports', 'e-sports', 'csgo', 'lol', 'dota', 'valorant', 'grandstand', 'christopher', 'alex', 'minaur', 'oconnell', 'player', 'players', 'singles', 'doubles', 'mixed', 'qualifying', 'main draw', 'round', 'final', 'semifinal', 'quarterfinal', 'robin', 'group', 'pool', 'bracket', 'softball', 'caribbean premier league', 'athletes unlimited', 'ncaa men\'s soccer'];
                        
                        if (nonFootballKeywords.some(keyword => title.includes(keyword))) {
                            return false;
                        }
                        
                        // Incluir solo fútbol REAL (más estricto)
                        const footballKeywords = ['football', 'futbol', 'liga', 'champions', 'bundesliga', 'serie a', 'la liga', 'mls', 'copa', 'championship', 'division', 'conference', 'playoff', 'play-off', 'play off'];
                        const isFootballByCategory = category === 'football';
                        const isFootballByKeywords = footballKeywords.some(keyword => 
                            title.includes(keyword) || category.includes(keyword)
                        );
                        
                        // Solo incluir si tiene "vs" Y es fútbol por categoría O keywords
                        const hasVs = (title.includes(' vs ') || title.includes(' versus '));
                        const isFootball = isFootballByCategory || (isFootballByKeywords && hasVs);
                        const isLive = getMatchStatus(match) === 'live';
                        
                        return isFootball && isLive;
                    });
                    
                    // Ordenar partidos en vivo por tiempo (más recientes primero)
                    const sortedLiveMatches = liveMatches.sort((a, b) => {
                        if (!a.time && !b.time) return 0;
                        if (!a.time) return 1;
                        if (!b.time) return -1;
                        
                        const timeA = new Date(a.time);
                        const timeB = new Date(b.time);
                        return timeB - timeA; // Orden descendente (más reciente primero)
                    });
                    
                    // Agregar partidos en vivo que no estén ya en la lista
                    const existingIds = new Set(finalMatches.map(m => m.id));
                    const existingTitles = new Set(finalMatches.map(m => m.title.toLowerCase().trim()));
                    
                    const additionalLiveMatches = sortedLiveMatches
                        .filter(match => {
                            // Verificar por ID y por título para evitar duplicados
                            const isDuplicateId = existingIds.has(match.id);
                            const isDuplicateTitle = existingTitles.has(match.title.toLowerCase().trim());
                            return !isDuplicateId && !isDuplicateTitle;
                        })
                        .slice(0, 8 - finalMatches.length);
                    
                    // Combinar partidos con espectadores + partidos en vivo
                    finalMatches = [...finalMatches, ...additionalLiveMatches];
                    
                    console.log(`✅ Fallback completado: ${finalMatches.length} partidos total (${sortedByTime.length} con espectadores + ${additionalLiveMatches.length} en vivo)`);
                    
                    // Verificar duplicados
                    const titles = finalMatches.map(m => m.title);
                    const duplicates = titles.filter((title, index) => titles.indexOf(title) !== index);
                    if (duplicates.length > 0) {
                        console.log('⚠️ Duplicados detectados:', duplicates);
                    } else {
                        console.log('✅ No hay duplicados en la lista final');
                    }
                }
                
                // Eliminar duplicados finales por título
                const uniqueFinalMatches = [];
                const seenTitles = new Set();
                
                for (const match of finalMatches) {
                    const normalizedTitle = match.title.toLowerCase().trim();
                    if (!seenTitles.has(normalizedTitle)) {
                        seenTitles.add(normalizedTitle);
                        uniqueFinalMatches.push(match);
                    }
                }
                
                console.log(`🎯 Lista final sin duplicados: ${uniqueFinalMatches.length} partidos`);
                uniqueFinalMatches.forEach((match, index) => {
                    console.log(`  ${index + 1}. ${match.title}`);
                });
                
                // GARANTIZAR MÍNIMO 5 TARJETAS: Si no hay suficientes, llenar con partidos programados
                if (uniqueFinalMatches.length < 5) {
                    console.log(`🔄 Solo ${uniqueFinalMatches.length} partidos, llenando con partidos programados...`);
                    
                    // Debug: contar partidos de fútbol totales
                    const totalFootballMatches = allMatches.filter(match => {
                        const title = match.title?.toLowerCase() || '';
                        const category = match.category?.toLowerCase() || '';
                        const footballKeywords = ['football', 'futbol', 'liga', 'champions', 'bundesliga', 'serie a', 'la liga', 'mls', 'copa', 'championship', 'division', 'conference', 'playoff', 'play-off', 'play off'];
                        const isFootballByCategory = category === 'football';
                        const isFootballByKeywords = footballKeywords.some(keyword => 
                            title.includes(keyword) || category.includes(keyword)
                        );
                        const hasVs = (title.includes(' vs ') || title.includes(' versus '));
                        return isFootballByCategory || (isFootballByKeywords && hasVs);
                    });
                    console.log(`🔍 Total partidos de fútbol disponibles: ${totalFootballMatches.length}`);
                    
                    // Obtener partidos programados como fallback
                    const scheduledMatches = allMatches.filter(match => {
                        // Excluir si ya está en la lista principal
                        if (seenTitles.has(match.title.toLowerCase().trim())) {
                            return false;
                        }
                        
                        // Filtro estricto de fútbol
                        const title = match.title?.toLowerCase() || '';
                        const category = match.category?.toLowerCase() || '';
                        
                        // Excluir otros deportes
                        const nonFootballKeywords = ['tennis', 'basketball', 'baseball', 'cricket', 'hockey', 'volleyball', 'rugby', 'golf', 'boxing', 'mma', 'ufc', 'wrestling', 'esports', 'e-sports', 'csgo', 'lol', 'dota', 'valorant', 'grandstand', 'christopher', 'alex', 'minaur', 'oconnell', 'player', 'players', 'singles', 'doubles', 'mixed', 'qualifying', 'main draw', 'round', 'final', 'semifinal', 'quarterfinal', 'robin', 'group', 'pool', 'bracket', 'softball', 'caribbean premier league', 'athletes unlimited', 'ncaa men\'s soccer'];
                        
                        if (nonFootballKeywords.some(keyword => title.includes(keyword))) {
                            return false;
                        }
                        
                        // Solo fútbol programado
                        const footballKeywords = ['football', 'futbol', 'liga', 'champions', 'bundesliga', 'serie a', 'la liga', 'mls', 'copa', 'championship', 'division', 'conference', 'playoff', 'play-off', 'play off'];
                        const isFootballByCategory = category === 'football';
                        const isFootballByKeywords = footballKeywords.some(keyword => 
                            title.includes(keyword) || category.includes(keyword)
                        );
                        const hasVs = (title.includes(' vs ') || title.includes(' versus '));
                        const isFootball = isFootballByCategory || (isFootballByKeywords && hasVs);
                        
                        // Debug: ver qué partidos están siendo evaluados
                        if (isFootball) {
                            const status = getMatchStatus(match);
                            console.log(`🔍 Evaluando en vivo/programado: ${match.title} - Status: ${status} - Time: ${match.time}`);
                        }
                        
                        // Usar exactamente la misma lógica que el filtro de programados
                        const isLive = getMatchStatus(match) === 'live';
                        const isScheduled = getMatchStatus(match) === 'scheduled';
                        
                        return isFootball && (isLive || isScheduled);
                    });
                    
                    console.log(`🔍 Partidos en vivo/programados encontrados: ${scheduledMatches.length}`);
                    if (scheduledMatches.length > 0) {
                        console.log('📋 Partidos en vivo/programados:', scheduledMatches.map(m => m.title));
                    }
                    
                    // Ordenar partidos programados por tiempo (más temprano primero)
                    const sortedScheduledMatches = scheduledMatches.sort((a, b) => {
                        if (!a.time && !b.time) return 0;
                        if (!a.time) return 1;
                        if (!b.time) return -1;
                        
                        const timeA = new Date(a.time);
                        const timeB = new Date(b.time);
                        return timeA - timeB;
                    });
                    
                    // Agregar partidos programados hasta completar mínimo 5
                    const neededMatches = 5 - uniqueFinalMatches.length;
                    const additionalScheduledMatches = sortedScheduledMatches.slice(0, neededMatches);
                    
                    // Combinar partidos principales + partidos programados
                    const finalWithScheduled = [...uniqueFinalMatches, ...additionalScheduledMatches];
                    
                    console.log(`✅ Llenado completado: ${finalWithScheduled.length} partidos total (${uniqueFinalMatches.length} principales + ${additionalScheduledMatches.length} programados)`);
                    
                    return finalWithScheduled.slice(0, 8);
                }
                
                return uniqueFinalMatches.slice(0, 8);
                
            } catch (error) {
                console.error('Error loading streams with most viewers:', error);
                return [];
            }
        }

        async function updateTrendingSection(showFallback = true) {
            const trendingContainer = document.getElementById('row-trending-top');
            if (!trendingContainer) return;
            
            // FALLBACK INMEDIATO: Solo mostrar en la carga inicial
            if (showFallback) {
                const rowTrack = trendingContainer.querySelector('.row-track');
                if (!rowTrack) return;
                
                // Mostrar fallback inmediato con partidos en vivo Y programados
                const fallbackMatches = allMatches.filter(match => {
                    const title = match.title?.toLowerCase() || '';
                    const category = match.category?.toLowerCase() || '';
                    
                    // Excluir otros deportes
                    const nonFootballKeywords = ['tennis', 'basketball', 'baseball', 'cricket', 'hockey', 'volleyball', 'rugby', 'golf', 'boxing', 'mma', 'ufc', 'wrestling', 'esports', 'e-sports', 'csgo', 'lol', 'dota', 'valorant', 'softball', 'caribbean premier league', 'athletes unlimited', 'ncaa men\'s soccer'];
                    
                    if (nonFootballKeywords.some(keyword => title.includes(keyword))) {
                        return false;
                    }
                    
                    // Usar exactamente la misma lógica que el filtro de programados
                    const footballKeywords = ['football', 'futbol', 'liga', 'champions', 'bundesliga', 'serie a', 'la liga', 'mls', 'copa', 'championship', 'division', 'conference', 'playoff', 'play-off', 'play off'];
                    const isFootballByCategory = category === 'football';
                    const isFootballByKeywords = footballKeywords.some(keyword => 
                        title.includes(keyword) || category.includes(keyword)
                    );
                    const hasVs = (title.includes(' vs ') || title.includes(' versus '));
                    const isFootball = isFootballByCategory || (isFootballByKeywords && hasVs);
                    const isLive = getMatchStatus(match) === 'live';
                    const isScheduled = getMatchStatus(match) === 'scheduled';
                    
                    return isFootball && (isLive || isScheduled);
                }).slice(0, 8);
                
                // Mostrar fallback inmediato
                if (fallbackMatches.length > 0) {
                    console.log('🔄 Mostrando fallback inmediato con', fallbackMatches.length, 'partidos (en vivo + programados)');
                    displayTrendingMatches(fallbackMatches);
                }
            }
            
            // Cargar streams con más espectadores desde la API de Streamed
            const topViewersMatches = await loadStreamsWithMostViewers();
            
            if (topViewersMatches.length === 0) {
                console.log('❌ No se encontraron partidos de fútbol con espectadores ni en vivo');
                return;
            }
            
            console.log('⚽ Actualizando sección de tendencias con', topViewersMatches.length, 'partidos de fútbol con más espectadores');

            // Base: los que traen espectadores (ya ordenados desc)
            const ordered = topViewersMatches;
            if (ordered.length === 0) return;

            // Relleno mixto: primero en vivo, luego programados (misma lógica de fútbol que fallback)
            const existingKeys = new Set(
                ordered.map(m => (m.id || m.slug || m.url || m.title || '').toString().toLowerCase())
            );

            const isFootballMatch = (match) => {
                const title = match.title?.toLowerCase() || '';
                const category = match.category?.toLowerCase() || '';
                const nonFootballKeywords = ['tennis', 'basketball', 'baseball', 'cricket', 'hockey', 'volleyball', 'rugby', 'golf', 'boxing', 'mma', 'ufc', 'wrestling', 'esports', 'e-sports', 'csgo', 'lol', 'dota', 'valorant', 'softball', 'caribbean premier league', 'athletes unlimited', "ncaa men's soccer"];
                if (nonFootballKeywords.some(k => title.includes(k))) return false;
                const footballKeywords = ['football', 'futbol', 'liga', 'champions', 'bundesliga', 'serie a', 'la liga', 'mls', 'copa', 'championship', 'division', 'conference', 'playoff', 'play-off', 'play off'];
                const isFootballByCategory = category === 'football';
                const isFootballByKeywords = footballKeywords.some(k => title.includes(k) || category.includes(k));
                const hasVs = (title.includes(' vs ') || title.includes(' versus '));
                return isFootballByCategory || (isFootballByKeywords && hasVs);
            };

            const pool = (allMatches || []).filter(m => isFootballMatch(m));

            const keyOf = (m) => (m.id || m.slug || m.url || m.title || '').toString().toLowerCase();

            const liveFill = pool.filter(m => getMatchStatus(m) === 'live' && !existingKeys.has(keyOf(m)));
            const scheduledFill = pool.filter(m => getMatchStatus(m) === 'scheduled' && !existingKeys.has(keyOf(m)));

            const finalList = [...ordered];
            const ensureMin = 5;
            for (const m of liveFill) {
                if (finalList.length >= ensureMin) break;
                finalList.push(m);
                existingKeys.add(keyOf(m));
            }
            for (const m of scheduledFill) {
                if (finalList.length >= ensureMin) break;
                finalList.push(m);
                existingKeys.add(keyOf(m));
            }

            displayTrendingMatches(finalList.slice(0, 8));
        }
        
        function displayTrendingMatches(matches) {
            const trendingContainer = document.getElementById('row-trending-top');
            if (!trendingContainer) return;
            
            const rowTrack = trendingContainer.querySelector('.row-track');
            if (!rowTrack) return;
            
            rowTrack.innerHTML = '';
            
            console.log('🎨 Creando', matches.length, 'tarjetas de tendencias...');
            console.log('📋 Partidos a mostrar:', matches.map(m => ({ id: m.id, title: m.title, hasSources: !!m.sources })));
            
            matches.forEach(match => {
                const status = getMatchStatus(match);
                
                // Debug: mostrar estado del partido
                const timeStr = match.time ? new Date(match.time).toLocaleString() : 'Sin tiempo';
                console.log(`🔍 ${match.title}: ${timeStr} -> Estado: ${status}`);
                
                // Extraer equipos del título (robusto)
                let homeTeam = 'Equipo Local';
                let awayTeam = 'Equipo Visitante';
                const parsed = extractTeamsFromTitle(match.title || '');
                if (parsed) {
                    homeTeam = parsed[0];
                    awayTeam = parsed[1];
                }

                // Limpiar y normalizar a español (solo equipos)
                homeTeam = normalizeTeamSpanish(limpiarNombreEquipo(homeTeam));
                awayTeam = normalizeTeamSpanish(limpiarNombreEquipo(awayTeam));
                
                // Categoría a mostrar con sistema de normalización (sin genérico)
                const displayCategory = getDisplayCategory(match);
                console.log('🎯 displayCategory para', match.title, ':', displayCategory);
                
                // Obtener URL de la imagen del partido - PRIORIZAR BADGES DE EQUIPOS
                let posterUrl = null;
                
                // Si NO tiene espectadores, priorizar badges de equipos
                if (!match.topViewers || match.topViewers === 0) {
                    // 1. Intentar construir poster compuesto: /api/images/poster/{home}/{away}.webp
                    if (match?.teams?.home?.badge && match?.teams?.away?.badge) {
                        const home = match.teams.home.badge;
                        const away = match.teams.away.badge;
                        posterUrl = `https://streamed.pk/api/images/poster/${home}/${away}.webp`;
                        console.log('🖼️ Usando poster compuesto (sin espectadores):', posterUrl);
                    }
                    // 2. Si no hay poster compuesto, intentar usar el badge del equipo local
                    else if (match?.teams?.home?.badge) {
                        posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.home.badge}.webp`;
                        console.log('🖼️ Usando badge equipo local (sin espectadores):', posterUrl);
                    }
                    // 3. Si no hay badge del equipo local, intentar con el equipo visitante
                    else if (match?.teams?.away?.badge) {
                        posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.away.badge}.webp`;
                        console.log('🖼️ Usando badge equipo visitante (sin espectadores):', posterUrl);
                    }
                    // 4. Si no hay estructura teams, intentar generar un badge basado en el título
                    else if (match.title) {
                        const titleHash = btoa(match.title).replace(/[^a-zA-Z0-9]/g, '').substring(0, 20);
                        posterUrl = `https://streamed.pk/api/images/proxy/${titleHash}.webp`;
                        console.log('🖼️ Usando badge generado del título (sin espectadores):', posterUrl);
                    }
                }
                
                // Si SÍ tiene espectadores o no se encontró badge, usar poster de Streamed
                if (!posterUrl) {
                // 1. Intentar usar el poster del partido si existe
                if (match.poster) {
                    if (match.poster.startsWith('http')) {
                        posterUrl = match.poster;
                        console.log('🖼️ Usando poster externo:', posterUrl);
                        } else {
                        if (match.poster.startsWith('/api/images/poster/')) {
                            posterUrl = `https://streamed.pk${match.poster}`;
                        } else if (match.poster.startsWith('api/images/poster/')) {
                            posterUrl = `https://streamed.pk/${match.poster}`;
                        } else if (match.poster.startsWith('/api/images/proxy/')) {
                            posterUrl = `https://streamed.pk${match.poster}`;
                        } else if (match.poster.startsWith('api/images/proxy/')) {
                            posterUrl = `https://streamed.pk/${match.poster}`;
                        } else {
                            posterUrl = `https://streamed.pk/api/images/proxy/${match.poster}`;
                        }
                        console.log('🖼️ Usando poster de Streamed:', posterUrl);
                    }
                }
                    // 2. Si no hay poster, intentar badges de equipos como fallback
                else if (match?.teams?.home?.badge && match?.teams?.away?.badge) {
                    const home = match.teams.home.badge;
                    const away = match.teams.away.badge;
                    posterUrl = `https://streamed.pk/api/images/poster/${home}/${away}.webp`;
                        console.log('🖼️ Usando poster compuesto (fallback):', posterUrl);
                }
                else if (match?.teams?.home?.badge) {
                    posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.home.badge}.webp`;
                        console.log('🖼️ Usando badge equipo local (fallback):', posterUrl);
                }
                else if (match?.teams?.away?.badge) {
                    posterUrl = `https://streamed.pk/api/images/proxy/${match.teams.away.badge}.webp`;
                        console.log('🖼️ Usando badge equipo visitante (fallback):', posterUrl);
                }
                else if (match.title) {
                    const titleHash = btoa(match.title).replace(/[^a-zA-Z0-9]/g, '').substring(0, 20);
                    posterUrl = `https://streamed.pk/api/images/proxy/${titleHash}.webp`;
                        console.log('🖼️ Usando badge generado del título (fallback):', posterUrl);
                }
                }
                
                if (!posterUrl) {
                    console.log('❌ No se encontró imagen para:', match.title, 'Teams:', match.teams);
                }
                
                // Wrapper para tarjeta + leyenda inferior
                const wrapper = document.createElement('div');
                wrapper.style.display = 'flex';
                wrapper.style.flexDirection = 'column';
                wrapper.style.width = '216px';
                wrapper.style.gap = '6px';
                wrapper.style.overflow = 'hidden';
                wrapper.style.flexShrink = '0';
                
                const tile = document.createElement('button');
                tile.className = 'tile';
                tile.setAttribute('role', 'listitem');
                tile.setAttribute('tabindex', '14');
                tile.onclick = () => openBestStream(match.id, match.title);
                
                // Renderizar con imagen específica con mejor manejo de errores
                if (posterUrl) {
                    tile.innerHTML = `
                        <img src="${posterUrl}" alt="${match.title || 'Partido'}" 
                             onerror="this.onerror=null; this.src='https://koogle.com/images/fallback.webp';" 
                             onload="this.nextElementSibling.style.display='none';" />
                        <div style="background: #2d2d2d; width: 100%; height: 100%; display: none; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 2rem;">⚽</div>
                        <div class="viewer-count" style="position: absolute; top: 8px; right: 8px; background: #111111; color: #ffffff; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; z-index: 10;">${match.topViewers || 0}</div>
                    `;
                } else {
                    // Sin imagen disponible: fondo con ícono de fútbol
                    tile.innerHTML = `
                        <div style="background: #2d2d2d; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 2rem;">⚽</div>
                        <div class="viewer-count" style="position: absolute; top: 8px; right: 8px; background: #111111; color: #ffffff; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; z-index: 10;">${match.topViewers || 0}</div>
                    `;
                }
                
                // NO agregar información superpuesta sobre la imagen
                
                // Leyenda debajo de la tarjeta (sin texto dentro de la tarjeta)
                const caption = document.createElement('div');
                caption.style.display = 'flex';
                caption.style.flexDirection = 'column';
                caption.style.gap = '2px';
                
                const titleLine = document.createElement('span');
                titleLine.style.color = '#ffffff';
                titleLine.style.fontSize = '0.9rem';
                titleLine.style.fontWeight = '700';
                titleLine.style.overflow = 'hidden';
                titleLine.style.textOverflow = 'ellipsis';
                titleLine.style.whiteSpace = 'nowrap';
                titleLine.style.maxWidth = '216px';
                titleLine.textContent = `${homeTeam} vs ${awayTeam}`;
                
                const sportLine = document.createElement('span');
                sportLine.style.color = '#b3b3b3';
                sportLine.style.fontSize = '0.7rem';
                sportLine.style.fontWeight = '500';
                sportLine.style.overflow = 'hidden';
                sportLine.style.textOverflow = 'ellipsis';
                sportLine.style.whiteSpace = 'nowrap';
                sportLine.style.maxWidth = '216px';
                sportLine.textContent = `${displayCategory} • ${match.topViewers || 0} espectadores`;
                if (!displayCategory) sportLine.style.display = 'none';
                
                caption.appendChild(titleLine);
                caption.appendChild(sportLine);
                
                wrapper.appendChild(tile);
                wrapper.appendChild(caption);
                
                rowTrack.appendChild(wrapper);
            });
            
            console.log('✅ Tarjetas de tendencias creadas y agregadas al DOM');
        }

        // Función para encontrar el elemento focusable más cercano (NAVEGACIÓN POR LÍNEAS)
        function findNearestFocusableElement(currentElement, direction) {
            const focusableElements = Array.from(document.querySelectorAll(
                'button, [tabindex]:not([tabindex="-1"]), a[href], input, select, textarea, [contenteditable="true"]'
            )).filter(el => {
                const rect = el.getBoundingClientRect();
                return rect.width > 0 && rect.height > 0 && !el.disabled && el.style.display !== 'none';
            });

            if (focusableElements.length === 0) return null;

            const currentRect = currentElement.getBoundingClientRect();
            const currentCenter = {
                x: currentRect.left + currentRect.width / 2,
                y: currentRect.top + currentRect.height / 2
            };

            let nearestElement = null;
            let minDistance = Infinity;

            // Agrupar elementos por líneas (filas)
            const lines = {};
            focusableElements.forEach(element => {
                const rect = element.getBoundingClientRect();
                const lineY = Math.round(rect.top / 50) * 50; // Agrupar por líneas de 50px
                if (!lines[lineY]) lines[lineY] = [];
                lines[lineY].push(element);
            });

            const currentLineY = Math.round(currentRect.top / 50) * 50;
            const currentLine = lines[currentLineY] || [];
            const currentLineIndex = currentLine.indexOf(currentElement);

            switch (direction) {
                case 'left':
                    // Navegar en la misma línea hacia la izquierda
                    if (currentLineIndex > 0) {
                        nearestElement = currentLine[currentLineIndex - 1];
                    }
                    break;
                    
                case 'right':
                    // Navegar en la misma línea hacia la derecha
                    if (currentLineIndex < currentLine.length - 1) {
                        nearestElement = currentLine[currentLineIndex + 1];
                    }
                    break;
                    
                case 'up':
                    // Buscar la línea de arriba
                    const lineKeys = Object.keys(lines).map(Number).sort((a, b) => b - a);
                    const currentLineKeyIndex = lineKeys.indexOf(currentLineY);
                    
                    if (currentLineKeyIndex < lineKeys.length - 1) {
                        const upperLineY = lineKeys[currentLineKeyIndex + 1];
                        const upperLine = lines[upperLineY];
                        
                        // Encontrar el elemento más cercano en la línea de arriba
                        upperLine.forEach(element => {
                            const rect = element.getBoundingClientRect();
                            const distance = Math.abs(rect.left - currentRect.left);
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestElement = element;
                            }
                        });
                    }
                    break;
                    
                case 'down':
                    // Buscar la línea de abajo
                    const lineKeysDown = Object.keys(lines).map(Number).sort((a, b) => a - b);
                    const currentLineKeyIndexDown = lineKeysDown.indexOf(currentLineY);
                    
                    if (currentLineKeyIndexDown < lineKeysDown.length - 1) {
                        const lowerLineY = lineKeysDown[currentLineKeyIndexDown + 1];
                        const lowerLine = lines[lowerLineY];
                        
                        // Encontrar el elemento más cercano en la línea de abajo
                        lowerLine.forEach(element => {
                            const rect = element.getBoundingClientRect();
                            const distance = Math.abs(rect.left - currentRect.left);
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestElement = element;
                            }
                        });
                    }
                    break;
            }

            return nearestElement;
        }

        // Event listeners
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeStreamOverlay();
                closeModal();
            }
            
            // Navegación NO circular con control remoto Android TV
            const focusedElement = document.activeElement;
            
            // PRIMERO: Navegación específica para botones VER AHORA - BLOQUEAR CARRUSEL
            if (focusedElement && focusedElement.classList.contains('btn-watch')) {
                if (e.key === 'ArrowLeft' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    const direction = e.key.replace('Arrow', '').toLowerCase();
                    const nearestElement = findNearestFocusableElement(focusedElement, direction);
                    if (nearestElement) {
                        nearestElement.focus();
                        console.log('🎯 Navegación botón VER AHORA:', direction, '->', nearestElement.textContent || nearestElement.className);
                    }
                    return false;
                } else if (e.key === 'ArrowRight') {
                    // BLOQUEAR COMPLETAMENTE la tecla derecha para botones VER AHORA
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.log('🚫 Tecla derecha bloqueada para botón VER AHORA');
                    return false;
                }
            }
            // SEGUNDO: Navegación para botones de filtros verticales - PERMITIR DERECHA
            else if (focusedElement && focusedElement.classList.contains('vertical-filter-btn')) {
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    e.stopPropagation();
                    // Buscar el elemento más cercano a la derecha
                    const nearestElement = findNearestFocusableElement(focusedElement, 'right');
                    if (nearestElement) {
                        nearestElement.focus();
                        console.log('🎯 Navegación filtro vertical a la derecha:', nearestElement.textContent || nearestElement.className);
                    }
                    return false;
                } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    e.stopPropagation();
                    const direction = e.key.replace('Arrow', '').toLowerCase();
                    const nearestElement = findNearestFocusableElement(focusedElement, direction);
                    if (nearestElement) {
                        nearestElement.focus();
                        console.log('🎯 Navegación filtro vertical:', direction, '->', nearestElement.textContent || nearestElement.className);
                    }
                    return false;
                }
            }
            // TERCERO: Si el foco está en el botón del carrusel, permitir navegación del carrusel
            else if (focusedElement && (focusedElement.id === 'carruselNext' || focusedElement.id === 'carruselPrev')) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    moverCarrusel(-1);
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    moverCarrusel(1);
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    const direction = e.key === 'ArrowUp' ? 'up' : 'down';
                    const nearestElement = findNearestFocusableElement(focusedElement, direction);
                    if (nearestElement) nearestElement.focus();
                }
            } else if (focusedElement && focusedElement.classList.contains('tile')) {
                // Navegación para tarjetas de tendencias
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    const direction = e.key === 'ArrowLeft' ? 'left' : 'right';
                    const nearestElement = findNearestFocusableElement(focusedElement, direction);
                    if (nearestElement) nearestElement.focus();
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    const direction = e.key === 'ArrowUp' ? 'up' : 'down';
                    const nearestElement = findNearestFocusableElement(focusedElement, direction);
                    if (nearestElement) nearestElement.focus();
                }
            } else if (focusedElement) {
                // Navegación general para cualquier elemento focusable
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    const direction = e.key.replace('Arrow', '').toLowerCase();
                    const nearestElement = findNearestFocusableElement(focusedElement, direction);
                    if (nearestElement) {
                        nearestElement.focus();
                        console.log('🎯 Navegación NO circular:', direction, '->', nearestElement.textContent || nearestElement.className);
                    }
                }
            }
        });

        // Función para establecer foco inicial
        function setInitialFocus() {
            // Establecer foco en el primer botón de filtros
            const firstFilterBtn = document.querySelector('.vertical-filter-btn[tabindex="1"]');
            if (firstFilterBtn) {
                firstFilterBtn.focus();
                console.log('🎯 Foco inicial establecido en filtros');
            }
        }





        // Initialize
        // Exponer overlay externo ANTES de cualquier posible uso en el HTML
        (function initExternalOverlayAPI(){
            function ensureExternalOverlay() {
                let ov = document.getElementById('externalOverlay');
                if (ov) return ov;
                ov = document.createElement('div');
                ov.id = 'externalOverlay';
                ov.style.position = 'fixed';
                ov.style.top = '0';
                ov.style.left = '0';
                ov.style.width = '1280px';
                ov.style.height = '720px';
                ov.style.background = 'rgba(0,0,0,0.9)';
                ov.style.zIndex = '10000';
                ov.style.display = 'none';
                ov.style.margin = '0 auto';
                ov.innerHTML = '\n  <div id="externalOverlayInner" style="position:absolute; inset:0;">\n    <iframe id="externalIframe" src="about:blank" style="position:absolute; inset:0; width:100%; height:100%; border:0; background:#000;"></iframe>\n  </div>\n';
                document.body.appendChild(ov);
                return ov;
            }
            function closeExternalOverlay() {
                const ov = document.getElementById('externalOverlay');
                const iframe = document.getElementById('externalIframe');
                if (iframe) iframe.src = 'about:blank';
                if (ov) ov.style.display = 'none';
                // Devolver foco al botón de filtro "En Vivo"
                try {
                    const liveFilterBtn = document.querySelector('.vertical-filter-btn[tabindex="1"]');
                    if (liveFilterBtn) liveFilterBtn.focus();
                } catch (_) {}
            }
            window.openExternalOverlay = function(url) {
                try {
                    const ov = ensureExternalOverlay();
                    const iframe = document.getElementById('externalIframe');
                    if (!iframe) {
                        window.location.href = url;
                        return;
                    }
                    iframe.src = url;
                    ov.style.display = 'block';
                } catch (err) {
                    console.error('No se pudo abrir overlay externo:', err);
                    window.location.href = url;
                }
            };
            // Permitir que la página embebida solicite cerrar el overlay
            window.addEventListener('message', (ev) => {
                try {
                    const data = ev.data;
                    if (data === 'close-external-overlay' || (data && data.type === 'EXTERNAL_OVERLAY_CLOSE')) {
                        closeExternalOverlay();
                    }
                } catch (_) {}
            });
        })();

        window.addEventListener('load', async () => {
            console.log('🚀 Streamed Replica iniciado');
            
            // 🎯 ESTABLECER FOCO INICIAL PRIMERO (antes que todo)
            setInitialFocus();
            
            // Cargar equipos de MLS primero
            await loadMLSTeams();
            
            // Luego cargar partidos
            await loadMatches('football'); // Load football matches by default
            
            // No aplicar filtro por defecto - mostrar todos los partidos (más rápido)
            
            // Cargar tendencias (partidos populares) independientemente
            updateTrendingSection();
            
            // Actualización automática de tendencias cada 10 segundos
            setInterval(() => {
                console.log('🔄 Actualizando tendencias automáticamente...');
                updateTrendingSection(false); // No mostrar fallback en actualizaciones automáticas
            }, 10000); // 10 segundos
            
            // Función global para abrir URL externa (intento de fullscreen gestionado por la página destino)
            window.openExternalFullScreen = function(url) {
                try {
                    const win = window.open(url, '_blank');
                    if (!win) {
                        console.warn('Popup bloqueado. Redirigiendo en la misma pestaña.');
                        window.location.href = url;
                        return;
                    }
                    win.focus();
                } catch (err) {
                    console.error('No se pudo abrir la URL externa:', err);
                    window.location.href = url;
                }
            }

            // Overlay dedicado para embebidos externos (no toca el overlay de streams)
            // Crea si no existe: #externalOverlay con iframe #externalIframe
            function ensureExternalOverlay() {
                let ov = document.getElementById('externalOverlay');
                if (ov) return ov;
                ov = document.createElement('div');
                ov.id = 'externalOverlay';
                ov.style.position = 'fixed';
                ov.style.top = '0';
                ov.style.left = '0';
                ov.style.width = '1280px';
                ov.style.height = '720px';
                ov.style.background = 'rgba(0,0,0,0.9)';
                ov.style.zIndex = '10000';
                ov.style.display = 'none';
                ov.style.margin = '0 auto';
                ov.innerHTML = '\n  <div id="externalOverlayInner" style="position:absolute; inset:0; display:flex; flex-direction:column;">\n    <div style="display:flex; align-items:center; justify-content:space-between; padding:8px 12px; background:#111; color:#fff;">\n      <div style="font-weight:700;">Apple TV</div>\n      <button id="externalOverlayClose" style="background:#ff6b35; color:#000; border:none; padding:6px 10px; border-radius:4px; font-weight:700; cursor:pointer;">Cerrar</button>\n    </div>\n    <iframe id="externalIframe" src="about:blank" style="flex:1; width:100%; border:0; background:#000;"></iframe>\n  </div>\n';
                document.body.appendChild(ov);
                document.getElementById('externalOverlayClose').onclick = () => {
                    const iframe = document.getElementById('externalIframe');
                    if (iframe) iframe.src = 'about:blank';
                    ov.style.display = 'none';
                };
                return ov;
            }

            window.openExternalOverlay = function(url) {
                try {
                    const ov = ensureExternalOverlay();
                    const iframe = document.getElementById('externalIframe');
                    if (!iframe) {
                        window.location.href = url;
                        return;
                    }
                    iframe.src = url;
                    ov.style.display = 'block';
                } catch (err) {
                    console.error('No se pudo abrir overlay externo:', err);
                    window.location.href = url;
                }
            }
            
            // Función para actualizar solo los contadores de espectadores de forma suave
            function updateViewerCounts() {
                const trendingContainer = document.getElementById('row-trending-top');
                if (!trendingContainer) return;
                
                const viewerCounts = trendingContainer.querySelectorAll('[data-match-id]');
                viewerCounts.forEach(async (element) => {
                    const matchId = element.getAttribute('data-match-id');
                    const viewerElement = element.querySelector('.viewer-count');
                    if (viewerElement) {
                        // Efecto de fade out
                        viewerElement.style.opacity = '0.5';
                        viewerElement.style.transform = 'scale(0.95)';
                        
                        // Simular actualización (aquí podrías hacer una llamada real a la API)
                        setTimeout(() => {
                            viewerElement.style.opacity = '1';
                            viewerElement.style.transform = 'scale(1)';
                        }, 150);
                    }
                });
            }
            
            // Desactivado: no reemplazar por Champions automáticamente
            // Si se requiere, usar el filtro manual desde el UI
         });

        function logCategoryDiagnostics(matches) {
            try {
                const distinct = new Set();
                const samples = [];
                matches.slice(0, 20).forEach(m => {
                    const cat = getCategory(m);
                    if (cat) distinct.add(cat);
                    samples.push({
                        title: m.title,
                        categoryDetected: cat,
                        raw: {
                            competition: m.competition,
                            tournament: m.tournament,
                            event: m.event,
                            category: m.category,
                            league: m.league,
                            sport: m.sport
                        }
                    });
                });
                console.log('🧭 Categorías detectadas (únicas):', Array.from(distinct));
                console.log('🧪 Muestras de categoría por partido:', samples);
            } catch (e) {
                console.log('Diag error:', e.message);
            }
        }

        function isTodayLocal(dateMs) {
            if (!dateMs || typeof dateMs !== 'number' || dateMs <= 0) return false;
            const d = new Date(dateMs);
            const now = new Date();
            return d.getFullYear() === now.getFullYear() && d.getMonth() === now.getMonth() && d.getDate() === now.getDate();
        }

        // Exponer openStreamOverlay globalmente para que applemejorado.html pueda usarla
        window.openStreamOverlay = openStreamOverlay;

        // Listener para recibir mensajes de applemejorado.html
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'OPEN_STREAM_OVERLAY') {
                console.log('🎬 Recibido mensaje para abrir stream overlay:', event.data);
                openStreamOverlay(event.data.url, event.data.title);
            }
        });
    </script>
</body>
</html>
